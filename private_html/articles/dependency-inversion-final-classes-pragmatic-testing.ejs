<%- include('../templates/layouts/article', {
    articleTitle: 'Dependency Inversion, Final Classes, and Pragmatic Testing in PHP 8.4',
    articleDescription: 'Master dependency inversion with final classes in PHP 8.4, learn when to use real objects vs mocks, and discover the pragmatic testing approach that combines Detroit and London schools for maintainable, testable code.',
    articleDate: '2025-08-11',
    articleCategory: 'php',
    articleReadingTime: '18',
    articleContent: `
        <div class="intro">
            <p class="lead">PHP 8.4 brings powerful features that change how we approach dependency inversion, class design, and testing strategies. SOLID principles remain timeless, but the implementation details have evolved with modern PHP capabilities. The testing community has moved beyond the traditional "mock everything" mentality.</p>
            
            <p>This guide explores three critical concepts: dependency inversion principle (DIP) with PHP 8.4's final classes, composition over inheritance patterns, and the pragmatic testing philosophy that combines Detroit School (classical) and London School (mockist) approaches. We'll examine when to use real objects versus mocks, how to leverage union types for flexible testing, and why the "mockist vs classical TDD" debate has evolved into a more sophisticated understanding of testing strategies.</p>
        </div>

        <section>
            <h2>Understanding Dependency Inversion in Modern PHP</h2>
            
            <p>The <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">Dependency Inversion Principle (DIP)</a> states that high-level modules should not depend on low-level modules. Both should depend on abstractions. In PHP 8.4, this principle takes on new dimensions with enhanced language features like <a href="https://wiki.php.net/rfc/property-hooks" target="_blank" rel="noopener">property hooks</a>, <a href="https://wiki.php.net/rfc/asymmetric-visibility" target="_blank" rel="noopener">asymmetric visibility</a>, and improved type system capabilities.</p>

            <h3>The Problem: Violating Dependency Inversion</h3>
            
            <p>Let's first examine what <em>not</em> to do. The following pseudocode demonstrates a classic violation of DIP:</p>

            <pre><code class="language-python">{{SNIPPET:dependency-inversion-final-classes/pseudocode-concepts.txt}}
</code></pre>

            <p>This inheritance-heavy approach creates several problems:</p>
            
            <ul>
                <li><strong>Tight coupling</strong>: High-level OrderProcessor depends directly on low-level MySqlDatabase</li>
                <li><strong>Hard to test</strong>: Cannot isolate business logic from database concerns</li>
                <li><strong>Brittle inheritance</strong>: Changes to base class affect all subclasses</li>
                <li><strong>Limited extensibility</strong>: Adding new database types requires modifying existing code</li>
            </ul>

            <p>Here's how this anti-pattern manifests in PHP code:</p>

            <pre><code class="language-php">{{SNIPPET:dependency-inversion-final-classes/wrong-approach.php}}
</code></pre>

            <h3>The Solution: Final Classes with Dependency Inversion</h3>
            
            <p>The modern PHP 8.4 approach leverages <a href="https://www.php.net/manual/en/language.oop5.final.php" target="_blank" rel="noopener">final classes</a> combined with <a href="https://www.php.net/manual/en/language.oop5.decon.php#language.oop5.decon.constructor.promotion" target="_blank" rel="noopener">dependency injection</a> to achieve proper inversion of control. Final classes prevent inheritance, forcing developers to use composition. This aligns perfectly with dependency inversion principles.</p>

            <pre><code class="language-php">{{SNIPPET:dependency-inversion-final-classes/right-approach.php}}
</code></pre>

            <h3>Key Benefits of Final Classes with DIP</h3>
            
            <ul>
                <li><strong>Composition over inheritance</strong>: Final classes force you to inject dependencies rather than extending base classes</li>
                <li><strong>Clear contracts</strong>: Interfaces define explicit contracts between components</li>
                <li><strong>Easy testing</strong>: Dependencies can be easily swapped for testing</li>
                <li><strong>Better encapsulation</strong>: Final classes prevent unwanted extension and maintain integrity</li>
                <li><strong>PHP 8.4 optimizations</strong>: Final classes enable better opcache optimizations</li>
            </ul>
        </section>

        <section>
            <h2>The Testing Philosophy: Detroit vs London Schools</h2>
            
            <p>The testing community has long been divided between two approaches. The <a href="https://martinfowler.com/articles/mocksArentStubs.html#ClassicalAndMockistTesting" target="_blank" rel="noopener">Detroit School</a> (classical/state-based testing) and <a href="https://martinfowler.com/articles/mocksArentStubs.html#ClassicalAndMockistTesting" target="_blank" rel="noopener">London School</a> (mockist/interaction-based testing). But modern practice has evolved toward a more pragmatic approach that combines both strategies.</p>

            <h3>Detroit School: Testing with Real Objects</h3>
            
            <p>The Detroit School, also known as the Classical approach, emphasizes:</p>
            
            <ul>
                <li><strong>State-based verification</strong>: Test what the system produces, not how it produces it</li>
                <li><strong>Real object usage</strong>: Use actual implementations when they're fast and deterministic</li>
                <li><strong>Inside-out development</strong>: Build from the domain core outward</li>
                <li><strong>Refactoring safety</strong>: Tests remain stable when implementation changes</li>
            </ul>

            <h3>London School: Testing with Mocks</h3>
            
            <p>The London School, or Mockist approach, focuses on:</p>
            
            <ul>
                <li><strong>Interaction-based verification</strong>: Test how objects collaborate</li>
                <li><strong>Heavy mocking</strong>: Mock all dependencies to isolate the system under test</li>
                <li><strong>Outside-in development</strong>: Start from user interface and work toward domain</li>
                <li><strong>Design feedback</strong>: Difficult mocking indicates poor design</li>
            </ul>

            <h3>The Pragmatic Approach: When to Use Each</h3>
            
            <p>Modern testing practice recognizes that both approaches have merit and should be used contextually:</p>

            <pre><code class="language-php">{{SNIPPET:dependency-inversion-final-classes/pragmatic-testing.php}}
</code></pre>

            <h3>Decision Matrix: Real Objects vs Mocks</h3>
            
            <table class="decision-matrix">
                <thead>
                    <tr>
                        <th>Use Real Objects When</th>
                        <th>Use Mocks When</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Fast to instantiate and execute</td>
                        <td>External dependencies (database, HTTP)</td>
                    </tr>
                    <tr>
                        <td>Deterministic behavior</td>
                        <td>Non-deterministic behavior (random, time)</td>
                    </tr>
                    <tr>
                        <td>No side effects</td>
                        <td>Testing error conditions</td>
                    </tr>
                    <tr>
                        <td>Pure functions or simple state</td>
                        <td>Interaction verification is important</td>
                    </tr>
                    <tr>
                        <td>Value objects and entities</td>
                        <td>Complex setup required</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>TypeScript Patterns: Learning from Structural Typing</h2>
            
            <p><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> offers valuable insights for PHP developers working with dependency inversion. PHP uses <a href="https://www.php.net/manual/en/language.oop5.basic.php" target="_blank" rel="noopener">nominal typing</a> (class-based), but TypeScript's <a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html#structural-typing" target="_blank" rel="noopener">structural typing</a> provides interesting patterns we can adapt:</p>

            <pre><code class="language-typescript">{{SNIPPET:dependency-inversion-final-classes/typescript-patterns.ts}}
</code></pre>

            <h3><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types" target="_blank" rel="noopener">Union Types</a> for Flexible Testing</h3>
            
            <p>The TypeScript code above demonstrates several advanced patterns that PHP developers can learn from. These include <a href="https://egghead.io/blog/using-branded-types-in-typescript" target="_blank" rel="noopener">branded types</a> for stronger type safety, <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions" target="_blank" rel="noopener">discriminated unions</a> for result types, and <a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html" target="_blank" rel="noopener">template literal types</a> for advanced configurations.</p>
            
            <p>TypeScript's <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types" target="_blank" rel="noopener">union types</a> inspire a flexible testing approach where the same interface can accommodate both real implementations and mocks. PHP doesn't have union types in the same way, but we can achieve similar flexibility through careful interface design.</p>

            <p>The key insight from TypeScript is that testing interfaces should be designed to accommodate both real and mock implementations naturally. You don't have to force a choice between approaches. The <a href="https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties" target="_blank" rel="noopener">readonly pattern</a> in TypeScript also provides inspiration for creating immutable dependencies in PHP.</p>
        </section>

        <section>
            <h2>Infrastructure as Code: Ansible and Dependency Inversion</h2>
            
            <p>Dependency inversion principles extend beyond application code to infrastructure automation. Ansible playbooks can demonstrate these concepts at the infrastructure level:</p>

            <pre><code class="language-yaml">{{SNIPPET:dependency-inversion-final-classes/ansible-infrastructure.yml}}
</code></pre>

            <h3>Infrastructure Testing Strategies</h3>
            
            <p>Just as in application testing, infrastructure code benefits from pragmatic testing approaches:</p>
            
            <ul>
                <li><strong>Use real tools</strong> for deterministic operations (file creation, package installation)</li>
                <li><strong>Mock external services</strong> when testing deployment scripts</li>
                <li><strong>Integration tests</strong> with containers or VMs for complete workflows</li>
                <li><strong>Fail-fast validation</strong> to catch configuration errors early</li>
            </ul>
        </section>

        <section>
            <h2>Bash Scripting: Dependency Injection in Shell Scripts</h2>
            
            <p>Even shell scripts can benefit from dependency inversion principles. Here's how to apply these concepts in Bash:</p>

            <pre><code class="language-bash">{{SNIPPET:dependency-inversion-final-classes/bash-deployment.sh}}
</code></pre>

            <h3>Shell Script Testing Patterns</h3>
            
            <p>Testing shell scripts requires creativity, but the same principles apply:</p>
            
            <ul>
                <li><strong>Environment variable injection</strong>: Use environment variables as dependency injection mechanism</li>
                <li><strong>Function composition</strong>: Break scripts into testable functions</li>
                <li><strong>Mock external commands</strong>: Override external commands with functions for testing</li>
                <li><strong>Real file operations</strong>: Use temporary directories for actual file system tests</li>
            </ul>
        </section>

        <section>
            <h2>PHP 8.4 Specific Features for Dependency Inversion</h2>
            
            <p>PHP 8.4 introduces several features that enhance dependency inversion implementation:</p>

            <h3><a href="https://wiki.php.net/rfc/property-hooks" target="_blank" rel="noopener">Property Hooks</a> for Lazy Initialization</h3>
            
            <pre><code class="language-php">class LazyOrderProcessor
{
    private ?OrderStorageInterface $storage = null;
    
    public OrderStorageInterface $storage {
        get {
            return $this->storage ??= $this->createStorage();
        }
        
        set {
            $this->storage = $value;
        }
    }
    
    private function createStorage(): OrderStorageInterface
    {
        return match($this->environment) {
            'testing' => new InMemoryOrderStorage(),
            'production' => new MySqlOrderStorage($this->connection),
            default => new SqliteOrderStorage()
        };
    }
}</code></pre>

            <h3><a href="https://wiki.php.net/rfc/asymmetric-visibility" target="_blank" rel="noopener">Asymmetric Visibility</a> for Immutable Dependencies</h3>
            
            <pre><code class="language-php">final class SecureOrderProcessor
{
    // Public read, private write - prevents external modification
    public private(set) PaymentGatewayInterface $paymentGateway;
    
    public function __construct(PaymentGatewayInterface $paymentGateway)
    {
        $this->paymentGateway = $paymentGateway;
    }
    
    // Gateway cannot be modified after construction
    // but can be read for testing and debugging
}</code></pre>

            <h3><a href="https://wiki.php.net/rfc/lazy_objects" target="_blank" rel="noopener">Lazy Objects</a> for Performance</h3>
            
            <p>PHP 8.4's <a href="https://wiki.php.net/rfc/lazy_objects" target="_blank" rel="noopener">lazy objects</a> feature allows sophisticated dependency injection patterns:</p>
            
            <pre><code class="language-php">$lazyDatabase = LazyObjectFactory::create(
    MySqlDatabase::class,
    function() {
        return new MySqlDatabase(
            $this->config['database']['host'],
            $this->config['database']['name']
        );
    }
);

// Database connection only created when first accessed
$processor = new OrderProcessor($validator, $taxCalculator, $lazyDatabase);</code></pre>
        </section>

        <section>
            <h2>Performance Considerations</h2>
            
            <p>Dependency inversion and testing strategies have performance implications you should consider:</p>

            <h3>Runtime Performance</h3>
            
            <ul>
                <li><strong>Final classes</strong>: Enable better opcache optimizations in PHP 8.4</li>
                <li><strong>Interface calls</strong>: Minimal overhead in modern PHP versions</li>
                <li><strong>Lazy loading</strong>: Defer expensive object creation until needed</li>
                <li><strong>Container caching</strong>: Cache dependency injection container configuration</li>
            </ul>

            <h3>Testing Performance</h3>
            
            <ul>
                <li><strong>Real objects</strong>: Often faster than mocks for simple operations</li>
                <li><strong>In-memory implementations</strong>: Provide realistic testing without I/O overhead</li>
                <li><strong>Mock setup overhead</strong>: Consider the cost of mock configuration</li>
                <li><strong>Parallel testing</strong>: Real objects enable better test parallelization</li>
            </ul>
        </section>

        <section>
            <h2>Common Pitfalls and Solutions</h2>

            <h3>Over-Engineering with Interfaces</h3>
            
            <p><strong>Problem</strong>: Creating interfaces for every class, even simple value objects.</p>
            <p><strong>Solution</strong>: Only create interfaces when you need polymorphism or dependency inversion. Simple data classes don't need interfaces.</p>

            <h3>Mock-Heavy Tests</h3>
            
            <p><strong>Problem</strong>: Mocking everything leads to brittle tests that break on refactoring.</p>
            <p><strong>Solution</strong>: Use the pragmatic approachâ€”mock external dependencies, use real objects for internal logic.</p>

            <h3>Inheritance Instead of Composition</h3>
            
            <p><strong>Problem</strong>: Using abstract base classes instead of dependency injection.</p>
            <p><strong>Solution</strong>: Favor final classes with injected dependencies over inheritance hierarchies.</p>

            <h3>Configuration Explosion</h3>
            
            <p><strong>Problem</strong>: Too many configuration options make the system hard to understand.</p>
            <p><strong>Solution</strong>: Provide sensible defaults and environment-based configurations.</p>
        </section>

        <section>
            <h2>Best Practices and Guidelines</h2>

            <h3>Design Guidelines</h3>
            
            <ol>
                <li><strong>Prefer final classes</strong>: Use final classes with dependency injection over inheritance</li>
                <li><strong>Design by contract</strong>: Create explicit interfaces for dependencies</li>
                <li><strong>Single responsibility</strong>: Each class should have one reason to change</li>
                <li><strong>Immutable dependencies</strong>: Don't allow dependencies to change after construction</li>
                <li><strong>Environment-based configuration</strong>: Use environment variables for different implementations</li>
            </ol>

            <h3>Testing Guidelines</h3>
            
            <ol>
                <li><strong>Start with real objects</strong>: Use real implementations unless there's a compelling reason to mock</li>
                <li><strong>Mock external boundaries</strong>: Always mock databases, HTTP services, file systems</li>
                <li><strong>Test behavior, not implementation</strong>: Focus on what the code does, not how</li>
                <li><strong>Use hybrid approaches</strong>: Combine real and mock objects in the same test</li>
                <li><strong>Maintain test speed</strong>: Fast tests encourage frequent execution</li>
            </ol>

            <h3>PHP 8.4 Specific Guidelines</h3>
            
            <ol>
                <li><strong>Leverage property hooks</strong>: Use for lazy initialization and validation</li>
                <li><strong>Use asymmetric visibility</strong>: Prevent unwanted modifications while maintaining transparency</li>
                <li><strong>Adopt lazy objects</strong>: For expensive dependencies that may not be used</li>
                <li><strong>Final by default</strong>: Make classes final unless extension is explicitly needed</li>
                <li><strong>Type everything</strong>: Use PHP 8.4's enhanced type system for better static analysis</li>
            </ol>
        </section>

        <section>
            <h2>Tools and Resources</h2>

            <h3>Essential PHP Tools</h3>
            
            <ul>
                <li><strong><a href="https://phpunit.de/" target="_blank" rel="noopener">PHPUnit 10+</a></strong>: Modern testing framework with improved mocking capabilities</li>
                <li><strong><a href="https://phpstan.org/" target="_blank" rel="noopener">PHPStan</a></strong>: Static analysis for catching dependency injection issues</li>
                <li><strong><a href="https://php-di.org/" target="_blank" rel="noopener">PHP-DI</a></strong>: Mature dependency injection container</li>
                <li><strong><a href="https://symfony.com/doc/current/service_container.html" target="_blank" rel="noopener">Symfony DI</a></strong>: Powerful dependency injection component</li>
                <li><strong><a href="https://psalm.dev/" target="_blank" rel="noopener">Psalm</a></strong>: Advanced static analysis with template support</li>
            </ul>

            <h3>Testing Resources</h3>
            
            <ul>
                <li><strong><a href="https://martinfowler.com/articles/mocksArentStubs.html" target="_blank" rel="noopener">Mocks Aren't Stubs</a></strong>: Martin Fowler's classic article on testing approaches</li>
                <li><strong><a href="https://www.growing-object-oriented-software.com/" target="_blank" rel="noopener">Growing Object-Oriented Software, Guided by Tests</a></strong>: The definitive book on London School TDD</li>
                <li><strong><a href="https://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html" target="_blank" rel="noopener">The Little Mocker</a></strong>: Uncle Bob's perspective on when to mock</li>
                <li><strong><a href="https://phptherightway.com/#testing" target="_blank" rel="noopener">PHP: The Right Way - Testing</a></strong>: Community guidelines for PHP testing</li>
            </ul>

            <h3>PHP 8.4 Documentation</h3>
            
            <ul>
                <li><strong><a href="https://www.php.net/releases/8.4/en.php" target="_blank" rel="noopener">PHP 8.4 Release Notes</a></strong>: Official feature documentation</li>
                <li><strong><a href="https://php.watch/versions/8.4" target="_blank" rel="noopener">PHP.Watch 8.4</a></strong>: Comprehensive guide to new features</li>
                <li><strong><a href="https://stitcher.io/blog/new-in-php-84" target="_blank" rel="noopener">What's New in PHP 8.4</a></strong>: Developer-focused feature overview</li>
            </ul>
        </section>

        <section>
            <h2>Conclusion</h2>
            
            <p>The combination of PHP 8.4's modern features, dependency inversion principles, and pragmatic testing approaches creates a powerful foundation for building maintainable, testable applications. Here are the key insights:</p>

            <ol>
                <li><strong>Final classes encourage composition</strong>: By preventing inheritance, final classes naturally lead to better dependency inversion patterns</li>
                <li><strong>Testing is contextual</strong>: The Detroit vs London school debate misses the point. Use the right approach for each situation</li>
                <li><strong>Real objects are undervalued</strong>: Many dependencies can and should be tested with real implementations for better confidence</li>
                <li><strong>Modern PHP enables elegant patterns</strong>: PHP 8.4's features make dependency inversion more natural and performant</li>
                <li><strong>Pragmatism over purity</strong>: Combine approaches based on practical concerns instead of ideological adherence</li>
            </ol>

            <p>As the PHP ecosystem continues to evolve, these patterns will become increasingly important for building scalable, maintainable applications. The investment in understanding and applying these concepts pays dividends in code quality, testing confidence, and long-term maintainability.</p>

            <p>The future of PHP development doesn't lie in choosing between different approaches. It lies in understanding when and how to apply each technique for maximum benefit. Whether you're building microservices, monoliths, or anything in between, these principles provide a solid foundation for clean, testable, and maintainable code.</p>
        </section>

        <style>
        .decision-matrix {
            width: 100%;
            margin: 2rem 0;
            border-collapse: collapse;
            background: var(--surface-color);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .decision-matrix th,
        .decision-matrix td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        .decision-matrix th {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }
        
        .decision-matrix tr:nth-child(even) {
            background: rgba(var(--primary-color-rgb), 0.02);
        }
        
        .decision-matrix tr:hover {
            background: rgba(var(--primary-color-rgb), 0.05);
        }
        </style>
    `
}) %>