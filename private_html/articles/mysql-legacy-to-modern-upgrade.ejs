<%- include('../templates/layouts/article', {
    articleTitle: 'Upgrading Legacy MySQL: From MyISAM to Modern MySQL 8.4',
    articleDescription: 'Technical guide to upgrading legacy MySQL databases from MyISAM with implied foreign keys to modern MySQL 8.4 with InnoDB, proper constraints, and modern features for enhanced security, performance, and data integrity.',
    articleDate: '2025-08-18',
    articleCategory: 'database',
    articleReadingTime: '10',
    articleSubreddit: 'Database',
    articleContent: `
        <div class="intro">
            <p class="lead">Legacy MySQL databases built on MyISAM with implied foreign key relationships lack fundamental capabilities you'd expect in modern database systems. This guide shows you how to upgrade to <a href="https://dev.mysql.com/doc/refman/8.4/en/" target="_blank" rel="noopener">MySQL 8.4 LTS</a> with <a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html" target="_blank" rel="noopener">InnoDB</a>, proper constraints, and modern features that didn't exist in the MySQL 4-5 era.</p>
        </div>

        <section>
            <h2>Executive Summary: Why Upgrade Legacy MySQL</h2>
            
            <p>Legacy MySQL databases running on <a href="https://dev.mysql.com/doc/refman/8.4/en/myisam-storage-engine.html" target="_blank" rel="noopener">MyISAM storage engine</a> with implied foreign key relationships pose substantial risks to modern businesses. These systems lack data integrity guarantees, transaction support, and modern security features.</p>

            <h3>Key Migration Benefits</h3>
            <ul>
                <li><strong>Data Integrity</strong>: ACID compliance and proper foreign key constraints prevent data corruption</li>
                <li><strong>Concurrent Access</strong>: Row-level locking instead of table-level locking</li>
                <li><strong>Crash Recovery</strong>: Automatic crash recovery without manual table repairs</li>
                <li><strong>Security</strong>: Transparent Data Encryption and role-based access control</li>
                <li><strong>Modern SQL</strong>: Window functions, CTEs, JSON support not available in MySQL 4-5</li>
            </ul>
        </section>

        <section>
            <h2>Understanding the Legacy Database Problem</h2>
            
            <h3>MyISAM Limitations</h3>
            <p><a href="https://dev.mysql.com/doc/refman/8.4/en/myisam-storage-engine.html" target="_blank" rel="noopener">MyISAM</a> was the default storage engine in MySQL 4 and 5.0, but has critical limitations:</p>

            <ul>
                <li><strong>Table-Level Locking</strong>: Any write operation blocks the entire table</li>
                <li><strong>No Transaction Support</strong>: No rollback capability for failed operations</li>
                <li><strong>No Foreign Key Constraints</strong>: Referential integrity must be maintained by application code</li>
                <li><strong>Corruption Risk</strong>: Tables frequently corrupt during crashes, requiring manual repair</li>
                <li><strong>No Encryption</strong>: Data stored in plaintext on disk</li>
            </ul>

            <h3>Implied vs Explicit Foreign Keys</h3>
            <p>Legacy systems often use naming conventions to imply relationships rather than database constraints:</p>

            <pre><code class="language-sql">-- Legacy: Implied relationship through column naming
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,  -- No actual constraint
    INDEX idx_customer (customer_id)
) ENGINE=MyISAM;

-- Modern: Explicit foreign key constraint
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
        ON DELETE RESTRICT ON UPDATE CASCADE
) ENGINE=InnoDB;
</code></pre>
        </section>

        <section>
            <h2>Real-World Data Corruption Scenarios and MySQL 8 Solutions</h2>
            
            <p>When you understand how data corruption happens in legacy systems, you'll see why MySQL 8's modern features are so important. These scenarios show actual problems that happen in production systems and how modern MySQL prevents them.</p>

            <h3>Scenario 1: The Double-Charge Problem - Why Transactions Matter</h3>
            
            <h4>The Problem: Partial Updates Without Transactions</h4>
            <p>In a MyISAM-based e-commerce system, a customer purchase needs multiple table updates. When the server crashes mid-operation, customers get charged but orders aren't created:</p>
            
            <pre><code class="language-sql">-- Legacy MyISAM: No transaction support
-- Step 1: Deduct from customer balance (SUCCEEDS)
UPDATE customer_accounts 
SET balance = balance - 500.00 
WHERE customer_id = 1234;

-- Step 2: Create order record (SERVER CRASHES HERE)
INSERT INTO orders (customer_id, amount, status) 
VALUES (1234, 500.00, 'pending');

-- Step 3: Update inventory (NEVER EXECUTES)
UPDATE inventory 
SET quantity = quantity - 1 
WHERE product_id = 5678;

-- RESULT: Customer charged $500, no order created, inventory not updated
-- Customer service nightmare: "Where's my order? You took my money!"</code></pre>

            <h4>The Solution: ACID Transactions in InnoDB</h4>
            <p>MySQL 8 with InnoDB ensures all operations succeed or all fail together:</p>
            
            <pre><code class="language-sql">-- Modern MySQL 8: Full transaction support
START TRANSACTION;

-- All operations are atomic
UPDATE customer_accounts 
SET balance = balance - 500.00 
WHERE customer_id = 1234;

INSERT INTO orders (customer_id, amount, status) 
VALUES (1234, 500.00, 'pending');

UPDATE inventory 
SET quantity = quantity - 1 
WHERE product_id = 5678;

-- If ANY step fails, ALL are rolled back
COMMIT;

-- With automatic rollback on errors
DELIMITER $$
CREATE PROCEDURE safe_purchase(
    IN p_customer_id INT,
    IN p_product_id INT,
    IN p_amount DECIMAL(10,2)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'Purchase failed - no charges made';
    END;
    
    START TRANSACTION;
    
    -- All succeed or all fail
    UPDATE customer_accounts 
    SET balance = balance - p_amount 
    WHERE customer_id = p_customer_id;
    
    INSERT INTO orders (customer_id, amount, status) 
    VALUES (p_customer_id, p_amount, 'pending');
    
    UPDATE inventory 
    SET quantity = quantity - 1 
    WHERE product_id = p_product_id;
    
    COMMIT;
END$$
DELIMITER ;</code></pre>

            <h3>Scenario 2: The Orphaned Order Problem - Why Foreign Keys Matter</h3>
            
            <h4>The Problem: Data Integrity Without Constraints</h4>
            <p>Without foreign keys, deleting customers leaves orphaned orders. This causes reporting errors and legal compliance issues:</p>
            
            <pre><code class="language-sql">-- Legacy MyISAM: No foreign key support
-- Admin deletes inactive customer
DELETE FROM customers WHERE customer_id = 5000;

-- Orders still reference deleted customer
SELECT COUNT(*) FROM orders WHERE customer_id = 5000;
-- Returns: 47 orphaned orders

-- Financial report crashes or shows incorrect totals
SELECT c.company_name, SUM(o.amount) as total_revenue
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id  -- NULL results!
GROUP BY c.customer_id;

-- GDPR compliance request fails
-- "Delete all my data" - but orders remain, violating privacy laws</code></pre>

            <h4>The Solution: Foreign Key Constraints</h4>
            <p>MySQL 8 prevents orphaned records through enforced relationships:</p>
            
            <pre><code class="language-sql">-- Modern MySQL 8: Foreign keys prevent orphans
ALTER TABLE orders
ADD CONSTRAINT fk_orders_customer
FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
ON DELETE RESTRICT;  -- Prevents deletion if orders exist

-- Attempting to delete customer with orders
DELETE FROM customers WHERE customer_id = 5000;
-- ERROR 1451: Cannot delete or update a parent row: foreign key constraint fails

-- For GDPR compliance: Cascade delete when appropriate
ALTER TABLE customer_personal_data
ADD CONSTRAINT fk_personal_customer
FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
ON DELETE CASCADE;  -- Personal data deleted with customer

-- For historical records: Set NULL for archived data
ALTER TABLE orders
ADD CONSTRAINT fk_orders_customer_archived
FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
ON DELETE SET NULL;  -- Preserves order history without customer</code></pre>

            <h3>Scenario 3: The Invalid Price Problem - Why Check Constraints Matter</h3>
            
            <h4>The Problem: Business Rules Not Enforced</h4>
            <p>Application bugs or direct database access can insert invalid data that breaks business logic:</p>
            
            <pre><code class="language-sql">-- Legacy MySQL: No check constraints
-- Bug in application sets negative prices
UPDATE products SET price = -99.99 WHERE product_id = 100;
-- SUCCESS - Database accepts negative price!

-- Promotional code sets discount over 100%
INSERT INTO promotions (code, discount_percent) 
VALUES ('MEGA_SALE', 150);
-- SUCCESS - 150% discount means we pay customers!

-- Date logic error books appointment in the past
INSERT INTO appointments (customer_id, appointment_date) 
VALUES (123, '2020-01-01');
-- SUCCESS - Appointment scheduled 5 years ago!

-- Financial losses accumulate before detection
-- Customer gets paid $50 to take a $100 product!</code></pre>

            <h4>The Solution: Check Constraints (MySQL 8.0.16+)</h4>
            <p>Database-level validation prevents invalid data no matter where it comes from:</p>
            
            <pre><code class="language-sql">-- Modern MySQL 8: Check constraints enforce business rules
ALTER TABLE products
ADD CONSTRAINT chk_positive_price 
CHECK (price >= 0),
ADD CONSTRAINT chk_price_range 
CHECK (price <= 999999.99);

ALTER TABLE promotions
ADD CONSTRAINT chk_valid_discount 
CHECK (discount_percent BETWEEN 0 AND 100);

ALTER TABLE appointments
ADD CONSTRAINT chk_future_appointment 
CHECK (appointment_date >= CURDATE());

-- Invalid operations now fail immediately
UPDATE products SET price = -99.99 WHERE product_id = 100;
-- ERROR 3819: Check constraint 'chk_positive_price' is violated

INSERT INTO promotions (code, discount_percent) VALUES ('MEGA', 150);
-- ERROR 3819: Check constraint 'chk_valid_discount' is violated

-- Complex business rules
ALTER TABLE orders
ADD CONSTRAINT chk_order_logic CHECK (
    (status = 'cancelled' AND cancelled_at IS NOT NULL) OR
    (status != 'cancelled' AND cancelled_at IS NULL)
);</code></pre>

            <h3>Scenario 4: The Inventory Race Condition - Why Row-Level Locking Matters</h3>
            
            <h4>The Problem: Table-Level Locks Cause Overselling</h4>
            <p>MyISAM's table-level locking creates race conditions where inventory goes negative:</p>
            
            <pre><code class="language-sql">-- Legacy MyISAM: Table-level locking
-- Two customers buying last item simultaneously

-- Customer A reads inventory (quantity = 1)
SELECT quantity FROM inventory WHERE product_id = 999;

-- Customer B reads inventory (quantity = 1)  
SELECT quantity FROM inventory WHERE product_id = 999;

-- Customer A updates (locks entire table)
UPDATE inventory SET quantity = 0 WHERE product_id = 999;

-- Customer B waits for lock, then updates
UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 999;

-- RESULT: quantity = -1, oversold inventory!
-- Warehouse can't fulfill order, customer complaints</code></pre>

            <h4>The Solution: Row-Level Locking with InnoDB</h4>
            <p>MySQL 8's row-level locking prevents race conditions:</p>
            
            <pre><code class="language-sql">-- Modern MySQL 8: Row-level locking prevents overselling
-- Pessimistic locking approach
START TRANSACTION;

-- Lock specific row for update
SELECT quantity FROM inventory 
WHERE product_id = 999 
FOR UPDATE;  -- Row locked until transaction completes

-- Check availability with lock held
IF quantity >= 1 THEN
    UPDATE inventory 
    SET quantity = quantity - 1 
    WHERE product_id = 999;
    
    INSERT INTO order_items (order_id, product_id, quantity)
    VALUES (@order_id, 999, 1);
ELSE
    -- Rollback and inform customer
    ROLLBACK;
    SIGNAL SQLSTATE '45000' 
    SET MESSAGE_TEXT = 'Product out of stock';
END IF;

COMMIT;

-- Optimistic locking with version numbers
ALTER TABLE inventory ADD COLUMN version INT DEFAULT 0;

UPDATE inventory 
SET quantity = quantity - 1,
    version = version + 1
WHERE product_id = 999 
    AND quantity >= 1
    AND version = @expected_version;

-- Check affected rows to detect concurrent modification
IF ROW_COUNT() = 0 THEN
    -- Another transaction modified the row
    SIGNAL SQLSTATE '45000' 
    SET MESSAGE_TEXT = 'Inventory was modified, please retry';
END IF;</code></pre>

            <h3>Scenario 5: The Crash Recovery Nightmare - Why InnoDB's Recovery Matters</h3>
            
            <h4>The Problem: MyISAM Corruption After Crash</h4>
            <p>Server crashes leave MyISAM tables corrupted. You have to repair them manually and often lose data:</p>
            
            <pre><code class="language-sql">-- Legacy MyISAM: After unexpected shutdown
-- Tables marked as crashed
SELECT table_name, table_comment 
FROM information_schema.tables 
WHERE engine = 'MyISAM' AND table_comment LIKE '%crashed%';

-- Manual repair required (may lose data)
REPAIR TABLE orders;  -- May take hours for large tables
-- Query OK, 847232 rows affected
-- Warning: Number of rows changed from 850000 to 847232
-- DATA LOSS: 2,768 orders lost!

-- During repair, table is locked
-- Application down, customers can't access
-- Recovery time: 2-6 hours for large database
-- Business impact: $50,000/hour in lost sales</code></pre>

            <h4>The Solution: InnoDB Automatic Crash Recovery</h4>
            <p>MySQL 8 automatically recovers from crashes without data loss:</p>
            
            <pre><code class="language-sql">-- Modern MySQL 8: Automatic crash recovery
-- InnoDB uses write-ahead logging (redo logs)

-- After crash, automatic recovery on startup
-- MySQL error log shows:
-- InnoDB: Starting crash recovery
-- InnoDB: Reading redo log from checkpoint
-- InnoDB: Applying redo log records
-- InnoDB: Rollback of uncommitted transactions
-- InnoDB: Crash recovery completed in 12 seconds

-- No data loss for committed transactions
SELECT COUNT(*) FROM orders;  -- All committed orders intact

-- Configure for faster recovery
SET GLOBAL innodb_fast_shutdown = 0;  -- Clean shutdown when possible
SET GLOBAL innodb_flush_log_at_trx_commit = 1;  -- Maximum durability
SET GLOBAL innodb_doublewrite = ON;  -- Prevent partial page writes

-- Point-in-time recovery with binary logs
-- Enable binary logging for full recovery capability
SET GLOBAL log_bin = ON;
SET GLOBAL binlog_format = 'ROW';

-- Recover to specific point before corruption
mysqlbinlog --stop-datetime="2024-12-01 10:00:00" \
    /var/log/mysql/binlog.000042 | mysql -u root -p</code></pre>

            <h3>Scenario 6: The Cascading Update Problem - Why Referential Actions Matter</h3>
            
            <h4>The Problem: Manual Cascade Updates Miss Records</h4>
            <p>Without referential actions, updating primary keys means you have to manually update all related tables. This is error-prone:</p>
            
            <pre><code class="language-sql">-- Legacy: Manual updates across tables
-- Company merger requires updating customer IDs

-- Update primary customer record
UPDATE customers SET customer_id = 9000 WHERE customer_id = 1000;

-- Must manually update every related table (error-prone)
UPDATE orders SET customer_id = 9000 WHERE customer_id = 1000;
UPDATE invoices SET customer_id = 9000 WHERE customer_id = 1000;
UPDATE support_tickets SET customer_id = 9000 WHERE customer_id = 1000;
-- Forgot customer_addresses table! Addresses now orphaned

-- Months later: Customer can't access their addresses
-- Support confused: "Your addresses disappeared after the merger"</code></pre>

            <h4>The Solution: Automatic Referential Actions</h4>
            <p>MySQL 8's CASCADE actions keep everything consistent across all tables:</p>
            
            <pre><code class="language-sql">-- Modern MySQL 8: Automatic cascade updates
-- Define referential actions once
ALTER TABLE orders
ADD CONSTRAINT fk_orders_customer_cascade
FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
ON UPDATE CASCADE;

ALTER TABLE invoices
ADD CONSTRAINT fk_invoices_customer_cascade
FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
ON UPDATE CASCADE;

ALTER TABLE customer_addresses
ADD CONSTRAINT fk_addresses_customer_cascade
FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
ON UPDATE CASCADE
ON DELETE CASCADE;  -- Addresses deleted with customer

-- Single update cascades everywhere
UPDATE customers SET customer_id = 9000 WHERE customer_id = 1000;
-- All related records automatically updated!

-- Verify cascade worked
SELECT 'orders' as table_name, COUNT(*) as updated_records
FROM orders WHERE customer_id = 9000
UNION ALL
SELECT 'invoices', COUNT(*)
FROM invoices WHERE customer_id = 9000
UNION ALL
SELECT 'addresses', COUNT(*)
FROM customer_addresses WHERE customer_id = 9000;</code></pre>
        </section>

        <section>
            <h2>Pre-Migration Assessment</h2>
            
            <p>Before you migrate, check your database structure and find potential issues.</p>

            <h3>Inventory Storage Engines</h3>
            <pre><code class="language-sql">-- Check which tables use MyISAM
SELECT 
    table_name,
    engine,
    table_rows,
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS size_mb
FROM information_schema.tables 
WHERE table_schema = DATABASE()
    AND engine = 'MyISAM'
ORDER BY size_mb DESC;
</code></pre>

            <h3>Find Orphaned Records</h3>
            <p>Identify records that would violate foreign key constraints:</p>

            <pre><code class="language-sql">-- Find child records without valid parent
SELECT child.id, child.parent_id
FROM child_table child
LEFT JOIN parent_table parent ON child.parent_id = parent.id
WHERE parent.id IS NULL
    AND child.parent_id IS NOT NULL;
</code></pre>

            <h3>Detect Duplicate Keys</h3>
            <pre><code class="language-sql">-- Find duplicates that would violate unique constraints
SELECT email, COUNT(*) as count
FROM users
GROUP BY email
HAVING COUNT(*) > 1;
</code></pre>
        </section>

        <section>
            <h2>Data Cleanup Before Migration</h2>
            
            <p>Clean data is essential for successful migration. Fix integrity issues before you convert storage engines.</p>

            <h3>Remove Orphaned Records</h3>
            <pre><code class="language-sql">-- Delete orphaned child records
DELETE child FROM child_table child
LEFT JOIN parent_table parent ON child.parent_id = parent.id
WHERE parent.id IS NULL 
    AND child.parent_id IS NOT NULL;

-- Or set to NULL if relationship is optional
UPDATE child_table child
LEFT JOIN parent_table parent ON child.parent_id = parent.id
SET child.parent_id = NULL
WHERE parent.id IS NULL 
    AND child.parent_id IS NOT NULL;
</code></pre>

            <h3>Handle Duplicate Records</h3>
            <pre><code class="language-sql">-- Keep oldest record, delete duplicates
DELETE t1 FROM users t1
INNER JOIN users t2 
WHERE t1.email = t2.email 
    AND t1.id > t2.id;
</code></pre>

            <h3>Fix Invalid Data Types</h3>
            <pre><code class="language-sql">-- Find invalid dates (common in MySQL 4-5 era)
SELECT * FROM orders 
WHERE order_date = '0000-00-00' 
    OR order_date < '1970-01-01';

-- Update to NULL or valid default
UPDATE orders 
SET order_date = NULL 
WHERE order_date = '0000-00-00';
</code></pre>
        </section>

        <section>
            <h2>Converting MyISAM to InnoDB</h2>
            
            <p>You need to convert the storage engine carefully to avoid locking issues and keep data consistent.</p>

            <h3>Basic Conversion</h3>
            <pre><code class="language-sql">-- Convert single table
ALTER TABLE table_name ENGINE=InnoDB;

-- Convert with progress monitoring (MySQL 5.6+)
ALTER TABLE table_name ENGINE=InnoDB, ALGORITHM=INPLACE, LOCK=NONE;
</code></pre>

            <h3>Batch Conversion Script</h3>
            <pre><code class="language-sql">-- Generate conversion statements for all MyISAM tables
SELECT CONCAT('ALTER TABLE ', table_name, ' ENGINE=InnoDB;') AS conversion_sql
FROM information_schema.tables
WHERE table_schema = DATABASE()
    AND engine = 'MyISAM'
ORDER BY table_rows ASC;  -- Convert smallest tables first
</code></pre>

            <h3>Configure InnoDB Settings</h3>
            <pre><code class="language-sql">-- Key InnoDB settings for production
SET GLOBAL innodb_buffer_pool_size = 2147483648;  -- 2GB, adjust based on RAM
SET GLOBAL innodb_log_file_size = 536870912;      -- 512MB
SET GLOBAL innodb_flush_log_at_trx_commit = 1;    -- Full ACID compliance
SET GLOBAL innodb_file_per_table = ON;            -- Separate files per table
</code></pre>
        </section>

        <section>
            <h2>Implementing Foreign Key Constraints</h2>
            
            <p>After you convert to InnoDB, add explicit foreign key constraints to enforce referential integrity.</p>

            <h3>Add Foreign Keys with Cascading Rules</h3>
            <pre><code class="language-sql">-- Add foreign key with appropriate cascading behavior
ALTER TABLE orders
ADD CONSTRAINT fk_orders_customer
FOREIGN KEY (customer_id) REFERENCES customers(id)
ON DELETE RESTRICT  -- Prevent deletion of customers with orders
ON UPDATE CASCADE;  -- Update customer_id if customer.id changes

-- For optional relationships
ALTER TABLE products
ADD CONSTRAINT fk_products_category
FOREIGN KEY (category_id) REFERENCES categories(id)
ON DELETE SET NULL  -- Set to NULL if category deleted
ON UPDATE CASCADE;
</code></pre>

            <h3>Verify Foreign Key Constraints</h3>
            <pre><code class="language-sql">-- List all foreign keys in database
SELECT 
    constraint_name,
    table_name,
    column_name,
    referenced_table_name,
    referenced_column_name
FROM information_schema.key_column_usage
WHERE referenced_table_name IS NOT NULL
    AND table_schema = DATABASE();
</code></pre>
        </section>

        <section>
            <h2>MySQL 8.0+ Features for Legacy Databases</h2>
            
            <p>MySQL 8.0 introduced features that completely change what's possible compared to MySQL 4-5.</p>

            <h3>Common Table Expressions (CTEs)</h3>
            <p>You can replace complex nested subqueries with readable CTEs (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Legacy MySQL 4-5: Nested subqueries
SELECT * FROM (
    SELECT customer_id, SUM(amount) as total
    FROM orders
    GROUP BY customer_id
) AS customer_totals
WHERE total > 1000;

-- Modern MySQL 8.0+: CTE
WITH customer_totals AS (
    SELECT customer_id, SUM(amount) as total
    FROM orders
    GROUP BY customer_id
)
SELECT * FROM customer_totals
WHERE total > 1000;
</code></pre>

            <h3>Window Functions</h3>
            <p>Analytics that were impossible or needed complex self-joins in MySQL 4-5:</p>
            
            <pre><code class="language-sql">-- Running total (impossible in MySQL 4-5 without variables)
SELECT 
    order_date,
    amount,
    SUM(amount) OVER (ORDER BY order_date) as running_total
FROM orders;

-- Ranking within groups
SELECT 
    category_id,
    product_name,
    price,
    RANK() OVER (PARTITION BY category_id ORDER BY price DESC) as price_rank
FROM products;
</code></pre>

            <h3>JSON Data Type</h3>
            <p>You can store and query semi-structured data (MySQL 5.7+):</p>
            
            <pre><code class="language-sql">-- Create table with JSON column
ALTER TABLE products ADD COLUMN attributes JSON;

-- Store structured data
UPDATE products 
SET attributes = JSON_OBJECT(
    'color', 'red',
    'size', 'large',
    'features', JSON_ARRAY('waterproof', 'lightweight')
);

-- Query JSON data
SELECT product_name
FROM products
WHERE JSON_EXTRACT(attributes, '$.color') = 'red';
</code></pre>

            <h3>Check Constraints</h3>
            <p>Enforce business rules at the database level (MySQL 8.0.16+):</p>
            
            <pre><code class="language-sql">-- Add check constraints
ALTER TABLE products
ADD CONSTRAINT chk_positive_price CHECK (price > 0),
ADD CONSTRAINT chk_valid_status CHECK (status IN ('active', 'inactive', 'discontinued'));

ALTER TABLE orders
ADD CONSTRAINT chk_valid_dates CHECK (ship_date >= order_date);
</code></pre>

            <h3>Instant DDL Operations</h3>
            <p>Make schema changes without table locks (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Add column instantly (no table rebuild)
ALTER TABLE large_table 
ADD COLUMN new_field VARCHAR(100) DEFAULT NULL,
ALGORITHM=INSTANT;

-- Operations that support INSTANT algorithm in MySQL 8.0+:
-- - Adding a column (with restrictions)
-- - Dropping a column
-- - Renaming a column
-- - Setting/dropping column default values
</code></pre>
        </section>

        <section>
            <h2>Performance Features in Modern MySQL</h2>
            
            <h3>Invisible Indexes</h3>
            <p>Test how removing an index affects performance without actually dropping it (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Make index invisible to test performance impact
ALTER TABLE orders ALTER INDEX idx_customer_id INVISIBLE;

-- Check if queries still perform well
-- If yes, drop the index; if no, make it visible again
ALTER TABLE orders ALTER INDEX idx_customer_id VISIBLE;
</code></pre>

            <h3>Descending Indexes</h3>
            <p>Optimize queries with DESC order (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Create descending index for queries that sort DESC
CREATE INDEX idx_created_desc ON posts(created_at DESC);

-- This query now uses the index efficiently
SELECT * FROM posts ORDER BY created_at DESC LIMIT 10;
</code></pre>

            <h3>Histogram Statistics</h3>
            <p>Get better query optimization for skewed data (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Create histogram for better statistics
ANALYZE TABLE orders UPDATE HISTOGRAM ON status;

-- View histogram information
SELECT * FROM information_schema.column_statistics
WHERE table_name = 'orders' AND column_name = 'status';
</code></pre>
        </section>

        <section>
            <h2>Security Enhancements</h2>
            
            <h3>Role-Based Access Control</h3>
            <p>Simplify permission management (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Create roles
CREATE ROLE 'app_read', 'app_write', 'app_admin';

-- Grant permissions to roles
GRANT SELECT ON mydb.* TO 'app_read';
GRANT INSERT, UPDATE, DELETE ON mydb.* TO 'app_write';
GRANT ALL ON mydb.* TO 'app_admin';

-- Assign roles to users
GRANT 'app_read' TO 'reader_user'@'localhost';
GRANT 'app_read', 'app_write' TO 'app_user'@'localhost';
</code></pre>

            <h3>Password Validation</h3>
            <p>Enforce strong passwords (MySQL 5.6+, better in 8.0):</p>
            
            <pre><code class="language-sql">-- Install and configure password validation
INSTALL COMPONENT 'file://component_validate_password';

SET GLOBAL validate_password.length = 12;
SET GLOBAL validate_password.mixed_case_count = 1;
SET GLOBAL validate_password.special_char_count = 1;
</code></pre>

            <h3>Transparent Data Encryption</h3>
            <p>Encrypt data at rest (InnoDB, MySQL 5.7+):</p>
            
            <pre><code class="language-sql">-- Enable encryption for new tables
SET GLOBAL default_table_encryption=ON;

-- Encrypt existing table
ALTER TABLE sensitive_data ENCRYPTION='Y';

-- Verify encryption status
SELECT table_name, create_options 
FROM information_schema.tables 
WHERE create_options LIKE '%ENCRYPTION%';
</code></pre>
        </section>

        <section>
            <h2>Migration Validation</h2>
            
            <p>After migration, make sure all changes worked.</p>

            <h3>Verify Storage Engines</h3>
            <pre><code class="language-sql">-- Confirm all tables use InnoDB
SELECT table_name, engine
FROM information_schema.tables
WHERE table_schema = DATABASE()
    AND engine != 'InnoDB';
</code></pre>

            <h3>Check Foreign Key Integrity</h3>
            <pre><code class="language-sql">-- Test foreign key constraints are working
-- This should fail if constraint is active
INSERT INTO orders (customer_id, amount) 
VALUES (99999, 100.00);  -- Non-existent customer
</code></pre>

            <h3>Performance Comparison</h3>
            <pre><code class="language-sql">-- Compare query performance
-- Before: Table lock wait
SHOW STATUS LIKE 'Table_locks_waited';

-- After: Row lock wait (should be much lower)
SHOW STATUS LIKE 'Innodb_row_lock_waits';
</code></pre>
        </section>

        <section>
            <h2>Conclusion: Modernizing Your Database</h2>
            
            <p>Upgrading from MyISAM to InnoDB with modern MySQL 8.4 features transforms a fragile legacy database into a robust, secure system. The migration gets rid of data corruption risks through ACID compliance. It enables concurrent access through row-level locking. And it provides modern SQL capabilities that were impossible in MySQL 4-5.</p>

            <p>Key technical improvements include:</p>
            <ul>
                <li>Transaction support preventing partial updates</li>
                <li>Foreign key constraints enforcing referential integrity</li>
                <li>Crash recovery without manual intervention</li>
                <li>Window functions and CTEs for complex analytics</li>
                <li>JSON support for flexible data structures</li>
                <li>Role-based access control and encryption</li>
            </ul>

            <p>For executives, this migration reduces operational risk and ensures regulatory compliance through encryption and audit capabilities. It enables new business capabilities through modern SQL features. The investment in migration prevents future data loss incidents and helps your organization use data as a strategic asset.</p>
        </section>
    `
}) %>