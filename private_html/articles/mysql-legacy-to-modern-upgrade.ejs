<%- include('../templates/layouts/article', {
    articleTitle: 'Upgrading Legacy MySQL: From MyISAM to Modern MySQL 8.4',
    articleDescription: 'Technical guide to upgrading legacy MySQL databases from MyISAM with implied foreign keys to modern MySQL 8.4 with InnoDB, proper constraints, and modern features for enhanced security, performance, and data integrity.',
    articleDate: '2025-08-18',
    articleCategory: 'database',
    articleReadingTime: '10',
    articleContent: `
        <div class="intro">
            <p class="lead">Legacy MySQL databases built on MyISAM with implied foreign key relationships lack fundamental capabilities expected in modern database systems. This guide demonstrates how to systematically upgrade to <a href="https://dev.mysql.com/doc/refman/8.4/en/" target="_blank" rel="noopener">MySQL 8.4 LTS</a> with <a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html" target="_blank" rel="noopener">InnoDB</a>, proper constraints, and modern features that didn't exist in the MySQL 4-5 era.</p>
        </div>

        <section>
            <h2>Executive Summary: Why Upgrade Legacy MySQL</h2>
            
            <p>Legacy MySQL databases running on <a href="https://dev.mysql.com/doc/refman/8.4/en/myisam-storage-engine.html" target="_blank" rel="noopener">MyISAM storage engine</a> with implied foreign key relationships pose substantial risks to modern businesses. These systems lack data integrity guarantees, transaction support, and modern security features.</p>

            <h3>Key Migration Benefits</h3>
            <ul>
                <li><strong>Data Integrity</strong>: ACID compliance and proper foreign key constraints prevent data corruption</li>
                <li><strong>Concurrent Access</strong>: Row-level locking instead of table-level locking</li>
                <li><strong>Crash Recovery</strong>: Automatic crash recovery without manual table repairs</li>
                <li><strong>Security</strong>: Transparent Data Encryption and role-based access control</li>
                <li><strong>Modern SQL</strong>: Window functions, CTEs, JSON support not available in MySQL 4-5</li>
            </ul>
        </section>

        <section>
            <h2>Understanding the Legacy Database Problem</h2>
            
            <h3>MyISAM Limitations</h3>
            <p><a href="https://dev.mysql.com/doc/refman/8.4/en/myisam-storage-engine.html" target="_blank" rel="noopener">MyISAM</a> was the default storage engine in MySQL 4 and 5.0, but has critical limitations:</p>

            <ul>
                <li><strong>Table-Level Locking</strong>: Any write operation blocks the entire table</li>
                <li><strong>No Transaction Support</strong>: No rollback capability for failed operations</li>
                <li><strong>No Foreign Key Constraints</strong>: Referential integrity must be maintained by application code</li>
                <li><strong>Corruption Risk</strong>: Tables frequently corrupt during crashes, requiring manual repair</li>
                <li><strong>No Encryption</strong>: Data stored in plaintext on disk</li>
            </ul>

            <h3>Implied vs Explicit Foreign Keys</h3>
            <p>Legacy systems often use naming conventions to imply relationships rather than database constraints:</p>

            <pre><code class="language-sql">-- Legacy: Implied relationship through column naming
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,  -- No actual constraint
    INDEX idx_customer (customer_id)
) ENGINE=MyISAM;

-- Modern: Explicit foreign key constraint
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
        ON DELETE RESTRICT ON UPDATE CASCADE
) ENGINE=InnoDB;
</code></pre>
        </section>

        <section>
            <h2>Pre-Migration Assessment</h2>
            
            <p>Before migration, assess your database structure and identify potential issues.</p>

            <h3>Inventory Storage Engines</h3>
            <pre><code class="language-sql">-- Check which tables use MyISAM
SELECT 
    table_name,
    engine,
    table_rows,
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS size_mb
FROM information_schema.tables 
WHERE table_schema = DATABASE()
    AND engine = 'MyISAM'
ORDER BY size_mb DESC;
</code></pre>

            <h3>Find Orphaned Records</h3>
            <p>Identify records that would violate foreign key constraints:</p>

            <pre><code class="language-sql">-- Find child records without valid parent
SELECT child.id, child.parent_id
FROM child_table child
LEFT JOIN parent_table parent ON child.parent_id = parent.id
WHERE parent.id IS NULL
    AND child.parent_id IS NOT NULL;
</code></pre>

            <h3>Detect Duplicate Keys</h3>
            <pre><code class="language-sql">-- Find duplicates that would violate unique constraints
SELECT email, COUNT(*) as count
FROM users
GROUP BY email
HAVING COUNT(*) > 1;
</code></pre>
        </section>

        <section>
            <h2>Data Cleanup Before Migration</h2>
            
            <p>Clean data is essential for successful migration. Fix integrity issues before converting storage engines.</p>

            <h3>Remove Orphaned Records</h3>
            <pre><code class="language-sql">-- Delete orphaned child records
DELETE child FROM child_table child
LEFT JOIN parent_table parent ON child.parent_id = parent.id
WHERE parent.id IS NULL 
    AND child.parent_id IS NOT NULL;

-- Or set to NULL if relationship is optional
UPDATE child_table child
LEFT JOIN parent_table parent ON child.parent_id = parent.id
SET child.parent_id = NULL
WHERE parent.id IS NULL 
    AND child.parent_id IS NOT NULL;
</code></pre>

            <h3>Handle Duplicate Records</h3>
            <pre><code class="language-sql">-- Keep oldest record, delete duplicates
DELETE t1 FROM users t1
INNER JOIN users t2 
WHERE t1.email = t2.email 
    AND t1.id > t2.id;
</code></pre>

            <h3>Fix Invalid Data Types</h3>
            <pre><code class="language-sql">-- Find invalid dates (common in MySQL 4-5 era)
SELECT * FROM orders 
WHERE order_date = '0000-00-00' 
    OR order_date < '1970-01-01';

-- Update to NULL or valid default
UPDATE orders 
SET order_date = NULL 
WHERE order_date = '0000-00-00';
</code></pre>
        </section>

        <section>
            <h2>Converting MyISAM to InnoDB</h2>
            
            <p>The storage engine conversion must be done carefully to avoid locking issues and ensure data consistency.</p>

            <h3>Basic Conversion</h3>
            <pre><code class="language-sql">-- Convert single table
ALTER TABLE table_name ENGINE=InnoDB;

-- Convert with progress monitoring (MySQL 5.6+)
ALTER TABLE table_name ENGINE=InnoDB, ALGORITHM=INPLACE, LOCK=NONE;
</code></pre>

            <h3>Batch Conversion Script</h3>
            <pre><code class="language-sql">-- Generate conversion statements for all MyISAM tables
SELECT CONCAT('ALTER TABLE ', table_name, ' ENGINE=InnoDB;') AS conversion_sql
FROM information_schema.tables
WHERE table_schema = DATABASE()
    AND engine = 'MyISAM'
ORDER BY table_rows ASC;  -- Convert smallest tables first
</code></pre>

            <h3>Configure InnoDB Settings</h3>
            <pre><code class="language-sql">-- Key InnoDB settings for production
SET GLOBAL innodb_buffer_pool_size = 2147483648;  -- 2GB, adjust based on RAM
SET GLOBAL innodb_log_file_size = 536870912;      -- 512MB
SET GLOBAL innodb_flush_log_at_trx_commit = 1;    -- Full ACID compliance
SET GLOBAL innodb_file_per_table = ON;            -- Separate files per table
</code></pre>
        </section>

        <section>
            <h2>Implementing Foreign Key Constraints</h2>
            
            <p>After converting to InnoDB, add explicit foreign key constraints to enforce referential integrity.</p>

            <h3>Add Foreign Keys with Cascading Rules</h3>
            <pre><code class="language-sql">-- Add foreign key with appropriate cascading behavior
ALTER TABLE orders
ADD CONSTRAINT fk_orders_customer
FOREIGN KEY (customer_id) REFERENCES customers(id)
ON DELETE RESTRICT  -- Prevent deletion of customers with orders
ON UPDATE CASCADE;  -- Update customer_id if customer.id changes

-- For optional relationships
ALTER TABLE products
ADD CONSTRAINT fk_products_category
FOREIGN KEY (category_id) REFERENCES categories(id)
ON DELETE SET NULL  -- Set to NULL if category deleted
ON UPDATE CASCADE;
</code></pre>

            <h3>Verify Foreign Key Constraints</h3>
            <pre><code class="language-sql">-- List all foreign keys in database
SELECT 
    constraint_name,
    table_name,
    column_name,
    referenced_table_name,
    referenced_column_name
FROM information_schema.key_column_usage
WHERE referenced_table_name IS NOT NULL
    AND table_schema = DATABASE();
</code></pre>
        </section>

        <section>
            <h2>MySQL 8.0+ Features for Legacy Databases</h2>
            
            <p>MySQL 8.0 introduced features that fundamentally change what's possible compared to MySQL 4-5.</p>

            <h3>Common Table Expressions (CTEs)</h3>
            <p>Replace complex nested subqueries with readable CTEs (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Legacy MySQL 4-5: Nested subqueries
SELECT * FROM (
    SELECT customer_id, SUM(amount) as total
    FROM orders
    GROUP BY customer_id
) AS customer_totals
WHERE total > 1000;

-- Modern MySQL 8.0+: CTE
WITH customer_totals AS (
    SELECT customer_id, SUM(amount) as total
    FROM orders
    GROUP BY customer_id
)
SELECT * FROM customer_totals
WHERE total > 1000;
</code></pre>

            <h3>Window Functions</h3>
            <p>Analytics that were impossible or required complex self-joins in MySQL 4-5:</p>
            
            <pre><code class="language-sql">-- Running total (impossible in MySQL 4-5 without variables)
SELECT 
    order_date,
    amount,
    SUM(amount) OVER (ORDER BY order_date) as running_total
FROM orders;

-- Ranking within groups
SELECT 
    category_id,
    product_name,
    price,
    RANK() OVER (PARTITION BY category_id ORDER BY price DESC) as price_rank
FROM products;
</code></pre>

            <h3>JSON Data Type</h3>
            <p>Store and query semi-structured data (MySQL 5.7+):</p>
            
            <pre><code class="language-sql">-- Create table with JSON column
ALTER TABLE products ADD COLUMN attributes JSON;

-- Store structured data
UPDATE products 
SET attributes = JSON_OBJECT(
    'color', 'red',
    'size', 'large',
    'features', JSON_ARRAY('waterproof', 'lightweight')
);

-- Query JSON data
SELECT product_name
FROM products
WHERE JSON_EXTRACT(attributes, '$.color') = 'red';
</code></pre>

            <h3>Check Constraints</h3>
            <p>Enforce business rules at database level (MySQL 8.0.16+):</p>
            
            <pre><code class="language-sql">-- Add check constraints
ALTER TABLE products
ADD CONSTRAINT chk_positive_price CHECK (price > 0),
ADD CONSTRAINT chk_valid_status CHECK (status IN ('active', 'inactive', 'discontinued'));

ALTER TABLE orders
ADD CONSTRAINT chk_valid_dates CHECK (ship_date >= order_date);
</code></pre>

            <h3>Instant DDL Operations</h3>
            <p>Schema changes without table locks (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Add column instantly (no table rebuild)
ALTER TABLE large_table 
ADD COLUMN new_field VARCHAR(100) DEFAULT NULL,
ALGORITHM=INSTANT;

-- Operations that support INSTANT algorithm in MySQL 8.0+:
-- - Adding a column (with restrictions)
-- - Dropping a column
-- - Renaming a column
-- - Setting/dropping column default values
</code></pre>
        </section>

        <section>
            <h2>Performance Features in Modern MySQL</h2>
            
            <h3>Invisible Indexes</h3>
            <p>Test index removal impact without actually dropping (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Make index invisible to test performance impact
ALTER TABLE orders ALTER INDEX idx_customer_id INVISIBLE;

-- Check if queries still perform well
-- If yes, drop the index; if no, make it visible again
ALTER TABLE orders ALTER INDEX idx_customer_id VISIBLE;
</code></pre>

            <h3>Descending Indexes</h3>
            <p>Optimize queries with DESC order (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Create descending index for queries that sort DESC
CREATE INDEX idx_created_desc ON posts(created_at DESC);

-- This query now uses the index efficiently
SELECT * FROM posts ORDER BY created_at DESC LIMIT 10;
</code></pre>

            <h3>Histogram Statistics</h3>
            <p>Better query optimization for skewed data (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Create histogram for better statistics
ANALYZE TABLE orders UPDATE HISTOGRAM ON status;

-- View histogram information
SELECT * FROM information_schema.column_statistics
WHERE table_name = 'orders' AND column_name = 'status';
</code></pre>
        </section>

        <section>
            <h2>Security Enhancements</h2>
            
            <h3>Role-Based Access Control</h3>
            <p>Simplified permission management (MySQL 8.0+):</p>
            
            <pre><code class="language-sql">-- Create roles
CREATE ROLE 'app_read', 'app_write', 'app_admin';

-- Grant permissions to roles
GRANT SELECT ON mydb.* TO 'app_read';
GRANT INSERT, UPDATE, DELETE ON mydb.* TO 'app_write';
GRANT ALL ON mydb.* TO 'app_admin';

-- Assign roles to users
GRANT 'app_read' TO 'reader_user'@'localhost';
GRANT 'app_read', 'app_write' TO 'app_user'@'localhost';
</code></pre>

            <h3>Password Validation</h3>
            <p>Enforce strong passwords (MySQL 5.6+, enhanced in 8.0):</p>
            
            <pre><code class="language-sql">-- Install and configure password validation
INSTALL COMPONENT 'file://component_validate_password';

SET GLOBAL validate_password.length = 12;
SET GLOBAL validate_password.mixed_case_count = 1;
SET GLOBAL validate_password.special_char_count = 1;
</code></pre>

            <h3>Transparent Data Encryption</h3>
            <p>Encrypt data at rest (InnoDB, MySQL 5.7+):</p>
            
            <pre><code class="language-sql">-- Enable encryption for new tables
SET GLOBAL default_table_encryption=ON;

-- Encrypt existing table
ALTER TABLE sensitive_data ENCRYPTION='Y';

-- Verify encryption status
SELECT table_name, create_options 
FROM information_schema.tables 
WHERE create_options LIKE '%ENCRYPTION%';
</code></pre>
        </section>

        <section>
            <h2>Migration Validation</h2>
            
            <p>After migration, validate that all changes were successful.</p>

            <h3>Verify Storage Engines</h3>
            <pre><code class="language-sql">-- Confirm all tables use InnoDB
SELECT table_name, engine
FROM information_schema.tables
WHERE table_schema = DATABASE()
    AND engine != 'InnoDB';
</code></pre>

            <h3>Check Foreign Key Integrity</h3>
            <pre><code class="language-sql">-- Test foreign key constraints are working
-- This should fail if constraint is active
INSERT INTO orders (customer_id, amount) 
VALUES (99999, 100.00);  -- Non-existent customer
</code></pre>

            <h3>Performance Comparison</h3>
            <pre><code class="language-sql">-- Compare query performance
-- Before: Table lock wait
SHOW STATUS LIKE 'Table_locks_waited';

-- After: Row lock wait (should be much lower)
SHOW STATUS LIKE 'Innodb_row_lock_waits';
</code></pre>
        </section>

        <section>
            <h2>Conclusion: Modernizing Your Database</h2>
            
            <p>Upgrading from MyISAM to InnoDB with modern MySQL 8.4 features transforms a fragile legacy database into a robust, secure system. The migration eliminates data corruption risks through ACID compliance, enables concurrent access through row-level locking, and provides modern SQL capabilities that were impossible in MySQL 4-5.</p>

            <p>Key technical improvements include:</p>
            <ul>
                <li>Transaction support preventing partial updates</li>
                <li>Foreign key constraints enforcing referential integrity</li>
                <li>Crash recovery without manual intervention</li>
                <li>Window functions and CTEs for complex analytics</li>
                <li>JSON support for flexible data structures</li>
                <li>Role-based access control and encryption</li>
            </ul>

            <p>For C-level stakeholders, this migration reduces operational risk, ensures regulatory compliance through encryption and audit capabilities, and enables new business capabilities through modern SQL features. The investment in migration prevents future data loss incidents and positions the organization to leverage data as a strategic asset.</p>
        </section>
    `
}) %>