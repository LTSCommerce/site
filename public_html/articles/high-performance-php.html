<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Proven techniques for optimizing PHP applications to handle high-turnover, high-complexity scenarios">
    <title>High-Performance PHP: Optimization Strategies | Joseph</title>
    <link rel="stylesheet" href="../css/main.css">
    <link rel="stylesheet" href="../css/articles.css">
    <link rel="stylesheet" href="../css/syntax-highlighting.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
</head>
<body>
    <header class="site-header">
        <nav class="nav-container">
            <div class="nav-brand">
                <a href="/" class="brand-link">Joseph</a>
            </div>
            <ul class="nav-menu">
                <li><a href="/" class="nav-link">Home</a></li>
                <li><a href="/services.html" class="nav-link">Services</a></li>
                <li><a href="/articles.html" class="nav-link">Articles</a></li>
                <li><a href="/about.html" class="nav-link">About</a></li>
                <li><a href="/author.html" class="nav-link">Author</a></li>
                <li><a href="/contact.html" class="nav-link">Contact</a></li>
            </ul>
            <button class="nav-toggle" aria-label="Toggle navigation">
                <span class="hamburger"></span>
            </button>
        </nav>
    </header>

    <main class="main-content">
        <article class="article-content">
            <div class="container">
                <header class="article-header">
                    <div class="article-meta">
                        <span class="article-category php">PHP</span>
                        <time datetime="2024-12-28">December 28, 2024</time>
                    </div>
                    <h1>High-Performance PHP: Optimization Strategies</h1>
                    <p class="article-lead">Proven techniques for optimizing PHP applications to handle high-turnover, high-complexity scenarios.</p>
                </header>

                <div class="article-body">
                    <p>PHP has a reputation for being slow, but that's largely outdated. Modern PHP 8.2+ with proper optimization can handle thousands of requests per second. The key is knowing where to optimize and how to measure the impact of your changes.</p>

                    <p>Over the years, I've optimized PHP applications handling millions of requests daily. Here are the techniques that deliver real performance gains.</p>

                    <h2>Performance Measurement Foundation</h2>

                    <h3>Profiling Tools</h3>

                    <p>You can't optimize what you don't measure. Essential profiling tools:</p>

                    <pre><code class="language-php"># Install Xdebug for profiling
pecl install xdebug

# php.ini configuration
zend_extension=xdebug.so
xdebug.mode=profile
xdebug.start_with_request=trigger
xdebug.output_dir="/tmp/xdebug"
xdebug.profiler_output_name="cachegrind.out.%p"</code></pre>

                    <p>Use with tools like KCacheGrind or Webgrind to visualize performance bottlenecks.</p>

                    <h3>Application Performance Monitoring</h3>

                    <pre><code class="language-php">&lt;?php

declare(strict_types=1);

namespace App\Monitoring;

use App\ValueObjects\{MetricName, Duration};
use App\Exceptions\TimerNotFoundException;
use Psr\Log\LoggerInterface;

final class PerformanceMonitor
{
    /** @var array&lt;string, float--&gt; */
    private array $timers = [];
    
    public function __construct(
        private readonly LoggerInterface $logger,
        private readonly MetricsCollector $metricsCollector,
    ) {}
    
    public function start(MetricName $name): void
    {
        $this-&gt;timers[$name-&gt;value] = hrtime(true);
    }
    
    public function end(MetricName $name): Duration
    {
        $timerKey = $name-&gt;value;
        
        if (!isset($this-&gt;timers[$timerKey])) {
            throw new TimerNotFoundException("Timer '{$timerKey}' not found");
        }
        
        $elapsed = Duration::fromNanoseconds(
            hrtime(true) - $this-&gt;timers[$timerKey]
        );
        
        unset($this-&gt;timers[$timerKey]);
        
        $this-&gt;metricsCollector-&gt;timing($name, $elapsed);
        
        $this-&gt;logger-&gt;debug('Performance metric recorded', [
            'metric' =&gt; $name-&gt;value,
            'duration_ms' =&gt; $elapsed-&gt;toMilliseconds(),
        ]);
        
        return $elapsed;
    }
}</code></pre>

                    <h2>OPcache Optimization</h2>

                    <p>OPcache is the most important PHP optimization. It caches compiled bytecode, eliminating the need to parse and compile PHP files on every request.</p>

                    <h3>Production OPcache Configuration</h3>

                    <pre><code class="language-php"># php.ini
opcache.enable=1
opcache.enable_cli=1
opcache.memory_consumption=512
opcache.interned_strings_buffer=64
opcache.max_accelerated_files=32531
opcache.validate_timestamps=0
opcache.save_comments=0
opcache.fast_shutdown=1
opcache.enable_file_override=1
opcache.optimization_level=0xffffffff

# JIT compilation for PHP 8.0+
opcache.jit_buffer_size=256M
opcache.jit=1255</code></pre>

                    <h3>OPcache Monitoring</h3>

                    <pre><code class="language-php">&lt;?php

declare(strict_types=1);

namespace App\Monitoring\OPcache;

use App\ValueObjects\{HitRate, MemoryUsage};
use App\Exceptions\OPcacheNotAvailableException;

final readonly class OPcacheMonitor
{
    public function __construct(
        private OPcacheStatusReader $statusReader,
        private OPcacheConfigReader $configReader,
    ) {}
    
    public function getStats(): OPcacheStats
    {
        if (!extension_loaded('opcache')) {
            throw new OPcacheNotAvailableException('OPcache extension not loaded');
        }
        
        $status = $this-&gt;statusReader-&gt;read();
        $config = $this-&gt;configReader-&gt;read();
        
        return new OPcacheStats(
            enabled: $status['opcache_enabled'],
            hitRate: HitRate::fromFloat($status['opcache_statistics']['opcache_hit_rate']),
            memoryUsage: MemoryUsage::fromArray($status['memory_usage']),
            cachedScripts: $status['opcache_statistics']['num_cached_scripts'],
            maxCachedKeys: $config['directives']['opcache.max_accelerated_files'],
            jitEnabled: $config['directives']['opcache.jit_buffer_size'] &gt; 0,
            jitBufferSize: $config['directives']['opcache.jit_buffer_size'],
        );
    }
    
    public function reset(): void
    {
        if (!opcache_reset()) {
            throw new OPcacheResetFailedException('Failed to reset OPcache');
        }
    }
    
    public function invalidateFile(string $filePath): void
    {
        if (!opcache_invalidate($filePath, true)) {
            throw new OPcacheInvalidationFailedException(
                "Failed to invalidate file: {$filePath}"
            );
        }
    }
}</code></pre>

                    <h2>Database Optimization</h2>

                    <h3>Connection Pooling</h3>

                    <p>Database connections are expensive. Use persistent connections wisely:</p>

                    <pre><code class="language-php">&lt;?php

declare(strict_types=1);

namespace App\Database\Connection;

use App\ValueObjects\{ConnectionString, ConnectionId};
use App\Exceptions\{ConnectionPoolExhaustedException, ConnectionCreationFailedException};
use WeakMap;

final class DatabaseConnectionPool
{
    /** @var WeakMap&lt;ConnectionId, PDO--&gt; */
    private WeakMap $connections;
    
    /** @var array&lt;string, connectionid=""&gt; */
    private array $connectionIds = [];
    
    public function __construct(
        private readonly ConnectionString $dsn,
        private readonly DatabaseCredentials $credentials,
        private readonly int $maxConnections = 20,
        private readonly ConnectionOptions $options = new ConnectionOptions(),
    ) {
        $this-&gt;connections = new WeakMap();
    }
    
    public function getConnection(): PDO
    {
        $connectionId = $this-&gt;findAvailableConnection() 
            ?? $this-&gt;createNewConnection();
        
        return $this-&gt;connections[$connectionId];
    }
    
    private function findAvailableConnection(): ?ConnectionId
    {
        foreach ($this-&gt;connectionIds as $id) {
            if ($this-&gt;connections-&gt;offsetExists($id)) {
                return $id;
            }
        }
        
        return null;
    }
    
    private function createNewConnection(): ConnectionId
    {
        if (count($this-&gt;connectionIds) &gt;= $this-&gt;maxConnections) {
            throw new ConnectionPoolExhaustedException(
                "Maximum connections ({$this-&gt;maxConnections}) reached"
            );
        }
        
        $connectionId = ConnectionId::generate();
        
        try {
            $pdo = new PDO(
                $this-&gt;dsn-&gt;value,
                $this-&gt;credentials-&gt;username,
                $this-&gt;credentials-&gt;password,
                $this-&gt;options-&gt;toPdoOptions(),
            );
            
            $this-&gt;connections[$connectionId] = $pdo;
            $this-&gt;connectionIds[] = $connectionId;
            
            return $connectionId;
        } catch (PDOException $e) {
            throw new ConnectionCreationFailedException(
                "Failed to create database connection: {$e-&gt;getMessage()}",
                previous: $e
            );
        }
    }
}&lt;/string,&gt;</code></pre>

                    <h3>Query Optimization</h3>

                    <pre><code class="language-php">&lt;?php

declare(strict_types=1);

namespace App\Database\Performance;

use App\ValueObjects\{QueryDuration, QueryMetrics};
use App\Exceptions\SlowQueryThresholdExceededException;
use Psr\Log\LoggerInterface;

final readonly class QueryOptimizer
{
    /** @var array&lt;int, QueryMetrics--&gt; */
    private array $queryLog = [];
    
    public function __construct(
        private PDO $pdo,
        private LoggerInterface $logger,
        private float $slowQueryThreshold = 0.1,
        private int $maxSlowQueries = 10,
    ) {}
    
    public function executeQuery(string $sql, array $params = []): array
    {
        $startTime = hrtime(true);
        
        $stmt = $this-&gt;pdo-&gt;prepare($sql);
        $stmt-&gt;execute($params);
        $result = $stmt-&gt;fetchAll();
        
        $duration = QueryDuration::fromNanoseconds(hrtime(true) - $startTime);
        
        if ($duration-&gt;exceeds($this-&gt;slowQueryThreshold)) {
            $this-&gt;logSlowQuery($sql, $params, $duration);
        }
        
        return $result;
    }
    
    private function logSlowQuery(string $sql, array $params, QueryDuration $duration): void
    {
        $metrics = new QueryMetrics(
            sql: $sql,
            parameters: $params,
            duration: $duration,
            executedAt: new DateTimeImmutable()
        );
        
        $this-&gt;queryLog[] = $metrics;
        
        $this-&gt;logger-&gt;warning('Slow query detected', [
            'sql' =&gt; $sql,
            'duration_ms' =&gt; $duration-&gt;toMilliseconds(),
            'parameters' =&gt; $params,
        ]);
        
        if (count($this-&gt;queryLog) &gt; $this-&gt;maxSlowQueries) {
            throw new SlowQueryThresholdExceededException(
                "Too many slow queries detected: {$this-&gt;maxSlowQueries}"
            );
        }
    }
    
    /** @return array<querymetrics> */
    public function getQueryLog(): array
    {
        return $this-&gt;queryLog;
    }
    
    public function getAverageQueryTime(): QueryDuration
    {
        if (empty($this-&gt;queryLog)) {
            return QueryDuration::fromMilliseconds(0);
        }
        
        $totalNanoseconds = array_sum(
            array_map(
                fn(QueryMetrics $metrics) =&gt; $metrics-&gt;duration-&gt;toNanoseconds(),
                $this-&gt;queryLog
            )
        );
        
        return QueryDuration::fromNanoseconds($totalNanoseconds / count($this-&gt;queryLog));
    }
}</querymetrics></code></pre>

                    <h2>Caching Strategies</h2>

                    <h3>Multi-Level Caching</h3>

                    <pre><code class="language-php">&lt;?php

declare(strict_types=1);

namespace App\Cache;

use App\ValueObjects\{CacheKey, CacheTTL};
use App\Exceptions\CacheSerializationException;
use Redis;
use WeakMap;

final class MultiLevelCacheManager
{
    /** @var array&lt;string, mixed--&gt; */
    private array $memoryCache = [];
    private readonly bool $apcuAvailable;
    
    public function __construct(
        private readonly Redis $redis,
        private readonly CacheTTL $defaultTtl = new CacheTTL(3600),
    ) {
        $this-&gt;apcuAvailable = extension_loaded('apcu');
    }
    
    public function get(CacheKey $key, ?callable $callback = null, ?CacheTTL $ttl = null): mixed
    {
        $keyString = $key-&gt;toString();
        $ttl ??= $this-&gt;defaultTtl;
        
        // Level 1: Memory cache (fastest)
        if (isset($this-&gt;memoryCache[$keyString])) {
            return $this-&gt;memoryCache[$keyString];
        }
        
        // Level 2: APCu (shared memory)
        if ($this-&gt;apcuAvailable && apcu_exists($keyString)) {
            $value = apcu_fetch($keyString);
            $this-&gt;memoryCache[$keyString] = $value;
            return $value;
        }
        
        // Level 3: Redis (distributed cache)
        $serializedValue = $this-&gt;redis-&gt;get($keyString);
        if ($serializedValue !== false) {
            try {
                $value = unserialize($serializedValue);
                $this-&gt;memoryCache[$keyString] = $value;
                
                if ($this-&gt;apcuAvailable) {
                    apcu_store($keyString, $value, $ttl-&gt;toSeconds());
                }
                
                return $value;
            } catch (Throwable $e) {
                throw new CacheSerializationException(
                    "Failed to unserialize cached value for key: {$keyString}",
                    previous: $e
                );
            }
        }
        
        // Generate value if callback provided
        if ($callback !== null) {
            $value = $callback();
            $this-&gt;set($key, $value, $ttl);
            return $value;
        }
        
        return null;
    }
    
    public function set(CacheKey $key, mixed $value, ?CacheTTL $ttl = null): void
    {
        $keyString = $key-&gt;toString();
        $ttl ??= $this-&gt;defaultTtl;
        
        // Store in all cache levels
        $this-&gt;memoryCache[$keyString] = $value;
        
        if ($this-&gt;apcuAvailable) {
            apcu_store($keyString, $value, $ttl-&gt;toSeconds());
        }
        
        try {
            $this-&gt;redis-&gt;setex($keyString, $ttl-&gt;toSeconds(), serialize($value));
        } catch (Throwable $e) {
            throw new CacheSerializationException(
                "Failed to serialize value for key: {$keyString}",
                previous: $e
            );
        }
    }
    
    public function delete(CacheKey $key): void
    {
        $keyString = $key-&gt;toString();
        
        unset($this-&gt;memoryCache[$keyString]);
        
        if ($this-&gt;apcuAvailable) {
            apcu_delete($keyString);
        }
        
        $this-&gt;redis-&gt;del($keyString);
    }
    
    public function clear(): void
    {
        $this-&gt;memoryCache = [];
        
        if ($this-&gt;apcuAvailable) {
            apcu_clear_cache();
        }
        
        $this-&gt;redis-&gt;flushdb();
    }
}</code></pre>

                    <h3>Smart Cache Invalidation</h3>

                    <pre><code class="language-php">&lt;?php

declare(strict_types=1);

namespace App\Cache;

use App\ValueObjects\{CacheKey, CacheTag, CacheTTL};
use App\Exceptions\CacheInvalidationException;
use App\Contracts\CacheInterface;
use Psr\Log\LoggerInterface;

final readonly class TaggedCacheInvalidator
{
    public function __construct(
        private CacheInterface $cache,
        private LoggerInterface $logger,
    ) {}
    
    /** @param array&lt;CacheTag--&gt; $tags */
    public function setWithTags(
        CacheKey $key,
        mixed $value,
        array $tags,
        ?CacheTTL $ttl = null
    ): void {
        $this-&gt;cache-&gt;set($key, $value, $ttl);
        
        // Associate key with tags
        foreach ($tags as $tag) {
            $tagKey = CacheKey::forTag($tag);
            $existingKeys = $this-&gt;cache-&gt;get($tagKey, fn() =&gt; []);
            $existingKeys[] = $key-&gt;toString();
            
            $this-&gt;cache-&gt;set(
                $tagKey,
                array_unique($existingKeys),
                $ttl
            );
        }
        
        $this-&gt;logger-&gt;debug('Cache entry created with tags', [
            'key' =&gt; $key-&gt;toString(),
            'tags' =&gt; array_map(fn(CacheTag $tag) =&gt; $tag-&gt;toString(), $tags),
        ]);
    }
    
    public function invalidateTag(CacheTag $tag): void
    {
        $tagKey = CacheKey::forTag($tag);
        $keys = $this-&gt;cache-&gt;get($tagKey, fn() =&gt; []);
        
        $invalidatedCount = 0;
        
        foreach ($keys as $keyString) {
            try {
                $this-&gt;cache-&gt;delete(CacheKey::fromString($keyString));
                $invalidatedCount++;
            } catch (Throwable $e) {
                $this-&gt;logger-&gt;error('Failed to invalidate cache key', [
                    'key' =&gt; $keyString,
                    'tag' =&gt; $tag-&gt;toString(),
                    'error' =&gt; $e-&gt;getMessage(),
                ]);
            }
        }
        
        $this-&gt;cache-&gt;delete($tagKey);
        
        $this-&gt;logger-&gt;info('Cache tag invalidated', [
            'tag' =&gt; $tag-&gt;toString(),
            'keys_invalidated' =&gt; $invalidatedCount,
        ]);
    }
    
    /** @param array<cachetag> $tags */
    public function invalidateTags(array $tags): void
    {
        foreach ($tags as $tag) {
            $this-&gt;invalidateTag($tag);
        }
    }
    
    public function invalidatePattern(string $pattern): void
    {
        if (!$this-&gt;cache instanceof RedisCache) {
            throw new CacheInvalidationException(
                'Pattern invalidation only supported for Redis cache'
            );
        }
        
        $keys = $this-&gt;cache-&gt;getRedisInstance()-&gt;keys($pattern);
        
        if (empty($keys)) {
            return;
        }
        
        $this-&gt;cache-&gt;getRedisInstance()-&gt;del($keys);
        
        $this-&gt;logger-&gt;info('Cache pattern invalidated', [
            'pattern' =&gt; $pattern,
            'keys_invalidated' =&gt; count($keys),
        ]);
    }
}</cachetag></code></pre>

                    <h2>Memory Management</h2>

                    <h3>Object Pooling</h3>

                    <pre><code class="language-php">&lt;?php

declare(strict_types=1);

namespace App\ObjectPool;

use App\Contracts\{PoolableInterface, ObjectFactoryInterface};
use App\Exceptions\PoolExhaustedException;
use App\ValueObjects\PoolSize;
use SplQueue;

final class ObjectPool
{
    private readonly SplQueue $pool;
    private int $currentSize = 0;
    
    public function __construct(
        private readonly ObjectFactoryInterface $factory,
        private readonly PoolSize $maxSize = new PoolSize(100),
    ) {
        $this-&gt;pool = new SplQueue();
    }
    
    public function get(): PoolableInterface
    {
        if ($this-&gt;pool-&gt;isEmpty()) {
            return $this-&gt;factory-&gt;create();
        }
        
        return $this-&gt;pool-&gt;dequeue();
    }
    
    public function return(PoolableInterface $object): void
    {
        if ($this-&gt;pool-&gt;count() &gt;= $this-&gt;maxSize-&gt;value) {
            // Pool is full, let object be garbage collected
            return;
        }
        
        // Reset object state before returning to pool
        $object-&gt;reset();
        
        $this-&gt;pool-&gt;enqueue($object);
    }
    
    public function size(): int
    {
        return $this-&gt;pool-&gt;count();
    }
    
    public function drain(): void
    {
        while (!$this-&gt;pool-&gt;isEmpty()) {
            $this-&gt;pool-&gt;dequeue();
        }
    }
}

// Usage example with factory
final readonly class HttpClientFactory implements ObjectFactoryInterface
{
    public function create(): PoolableInterface
    {
        return new PoolableHttpClient(
            new GuzzleHttp\Client([
                'timeout' =&gt; 30,
                'connect_timeout' =&gt; 5,
            ])
        );
    }
}

$httpClientPool = new ObjectPool(
    new HttpClientFactory(),
    new PoolSize(50)
);

function makeHttpRequest(string $url): string
{
    $client = $httpClientPool-&gt;get();
    try {
        $response = $client-&gt;get($url);
        return $response-&gt;getBody();
    } finally {
        $httpClientPool-&gt;return($client);
    }
}</code></pre>

                    <h3>Memory Leak Detection</h3>

                    <pre><code class="language-php">&lt;?php

declare(strict_types=1);

namespace App\Profiling;

use App\ValueObjects\{MemoryUsage, Duration, CheckpointName};
use App\Exceptions\CheckpointNotFoundException;
use DateTimeImmutable;

final class MemoryProfiler
{
    /** @var array&lt;string, MemoryCheckpoint--&gt; */
    private array $checkpoints = [];
    
    public function checkpoint(CheckpointName $name): void
    {
        $this-&gt;checkpoints[$name-&gt;value] = new MemoryCheckpoint(
            name: $name,
            memoryUsage: MemoryUsage::current(),
            peakMemoryUsage: MemoryUsage::peak(),
            timestamp: new DateTimeImmutable()
        );
    }
    
    public function getDiff(CheckpointName $from, CheckpointName $to): MemoryDiff
    {
        $fromCheckpoint = $this-&gt;checkpoints[$from-&gt;value] ?? null;
        $toCheckpoint = $this-&gt;checkpoints[$to-&gt;value] ?? null;
        
        if ($fromCheckpoint === null || $toCheckpoint === null) {
            throw new CheckpointNotFoundException(
                "Checkpoint not found: {$from-&gt;value} or {$to-&gt;value}"
            );
        }
        
        return new MemoryDiff(
            from: $fromCheckpoint,
            to: $toCheckpoint,
            memoryDiff: $toCheckpoint-&gt;memoryUsage-&gt;subtract($fromCheckpoint-&gt;memoryUsage),
            peakDiff: $toCheckpoint-&gt;peakMemoryUsage-&gt;subtract($fromCheckpoint-&gt;peakMemoryUsage),
            timeDiff: Duration::between($fromCheckpoint-&gt;timestamp, $toCheckpoint-&gt;timestamp)
        );
    }
    
    /** @return array&lt;string, memorydiff=""&gt; */
    public function getReport(): array
    {
        $report = [];
        $checkpointNames = array_keys($this-&gt;checkpoints);
        
        for ($i = 1; $i &lt; count($checkpointNames); $i++) {
            $from = CheckpointName::fromString($checkpointNames[$i - 1]);
            $to = CheckpointName::fromString($checkpointNames[$i]);
            $report["{$from-&gt;value} → {$to-&gt;value}"] = $this-&gt;getDiff($from, $to);
        }
        
        return $report;
    }
    
    public function reset(): void
    {
        $this-&gt;checkpoints = [];
    }
    
    public function hasCheckpoint(CheckpointName $name): bool
    {
        return isset($this-&gt;checkpoints[$name-&gt;value]);
    }
    
    public function getCheckpoint(CheckpointName $name): ?MemoryCheckpoint
    {
        return $this-&gt;checkpoints[$name-&gt;value] ?? null;
    }
}&lt;/string,&gt;</code></pre>

                    <h2>Asynchronous Processing</h2>

                    <h3>Job Queue Implementation</h3>

                    <pre><code class="language-php">&lt;?php

declare(strict_types=1);

namespace App\Queue;

use App\ValueObjects\{QueueName, JobDelay, JobId};
use App\Exceptions\{JobSerializationException, QueueOperationException};
use App\Contracts\{JobInterface, QueueInterface};
use Redis;
use Psr\Log\LoggerInterface;

final readonly class RedisJobQueue implements QueueInterface
{
    public function __construct(
        private Redis $redis,
        private QueueName $queueName,
        private LoggerInterface $logger,
    ) {}
    
    public function push(JobInterface $job, ?JobDelay $delay = null): void
    {
        try {
            $payload = serialize($job);
        } catch (Throwable $e) {
            throw new JobSerializationException(
                "Failed to serialize job: {$job::class}",
                previous: $e
            );
        }
        
        if ($delay !== null && $delay-&gt;getSeconds() &gt; 0) {
            $this-&gt;redis-&gt;zadd(
                "queue:{$this-&gt;queueName-&gt;value}:delayed",
                time() + $delay-&gt;getSeconds(),
                $payload
            );
        } else {
            $this-&gt;redis-&gt;lpush("queue:{$this-&gt;queueName-&gt;value}", $payload);
        }
        
        $this-&gt;logger-&gt;debug('Job pushed to queue', [
            'queue' =&gt; $this-&gt;queueName-&gt;value,
            'job_type' =&gt; $job::class,
            'delayed' =&gt; $delay?-&gt;getSeconds() ?? 0,
        ]);
    }
    
    public function pop(int $timeout = 0): ?JobInterface
    {
        $this-&gt;moveDelayedJobs();
        
        $result = $this-&gt;redis-&gt;brpop("queue:{$this-&gt;queueName-&gt;value}", $timeout);
        
        if (!$result) {
            return null;
        }
        
        try {
            return unserialize($result[1]);
        } catch (Throwable $e) {
            throw new JobSerializationException(
                "Failed to unserialize job from queue: {$this-&gt;queueName-&gt;value}",
                previous: $e
            );
        }
    }
    
    private function moveDelayedJobs(): void
    {
        $now = time();
        $jobs = $this-&gt;redis-&gt;zrangebyscore(
            "queue:{$this-&gt;queueName-&gt;value}:delayed",
            0,
            $now
        );
        
        foreach ($jobs as $job) {
            $this-&gt;redis-&gt;lpush("queue:{$this-&gt;queueName-&gt;value}", $job);
            $this-&gt;redis-&gt;zrem("queue:{$this-&gt;queueName-&gt;value}:delayed", $job);
        }
    }
    
    public function size(): int
    {
        return $this-&gt;redis-&gt;llen("queue:{$this-&gt;queueName-&gt;value}");
    }
    
    public function clear(): void
    {
        $this-&gt;redis-&gt;del("queue:{$this-&gt;queueName-&gt;value}");
        $this-&gt;redis-&gt;del("queue:{$this-&gt;queueName-&gt;value}:delayed");
    }
}

abstract readonly class Job implements JobInterface
{
    protected int $attempts = 0;
    protected int $maxAttempts = 3;
    
    public function __construct(
        protected readonly JobId $id,
        protected readonly array $data = [],
    ) {}
    
    abstract public function handle(): void;
    
    public function failed(Throwable $exception): void
    {
        // Override in subclasses for custom failure handling
    }
    
    public function shouldRetry(): bool
    {
        return $this-&gt;attempts &lt; $this-&gt;maxAttempts;
    }
    
    public function incrementAttempts(): void
    {
        $this-&gt;attempts++;
    }
    
    public function getAttempts(): int
    {
        return $this-&gt;attempts;
    }
    
    public function getMaxAttempts(): int
    {
        return $this-&gt;maxAttempts;
    }
    
    public function getId(): JobId
    {
        return $this-&gt;id;
    }
}</code></pre>

                    <h2>HTTP Performance Optimization</h2>

                    <h3>Response Streaming</h3>

                    <pre><code class="language-php">class StreamingResponse {
    private $callback;
    private $headers = [];
    
    public function __construct(callable $callback) {
        $this-&gt;callback = $callback;
    }
    
    public function setHeader(string $name, string $value): void {
        $this-&gt;headers[$name] = $value;
    }
    
    public function send(): void {
        // Send headers
        foreach ($this-&gt;headers as $name =&gt; $value) {
            header("{$name}: {$value}");
        }
        
        // Disable output buffering
        if (ob_get_level()) {
            ob_end_clean();
        }
        
        // Send content in chunks
        ($this-&gt;callback)();
    }
}

// Usage for large data sets
function streamLargeDataset(): void {
    $response = new StreamingResponse(function() {
        echo "[\n";
        
        $first = true;
        foreach (getLargeDataset() as $item) {
            if (!$first) {
                echo ",\n";
            }
            echo json_encode($item);
            $first = false;
            
            // Flush output buffer
            flush();
        }
        
        echo "\n]";
    });
    
    $response-&gt;setHeader('Content-Type', 'application/json');
    $response-&gt;send();
}</code></pre>

                    <h3>Response Compression</h3>

                    <pre><code class="language-php">class CompressionMiddleware {
    private $minSize = 1024;
    private $supportedEncodings = ['gzip', 'deflate'];
    
    public function handle(Request $request, callable $next): Response {
        $response = $next($request);
        
        // Check if compression is supported
        $acceptEncoding = $request-&gt;getHeader('Accept-Encoding');
        $encoding = $this-&gt;getBestEncoding($acceptEncoding);
        
        if (!$encoding || strlen($response-&gt;getBody()) &lt; $this-&gt;minSize) {
            return $response;
        }
        
        // Compress response
        $compressed = $this-&gt;compress($response-&gt;getBody(), $encoding);
        
        return $response
            -&gt;withBody($compressed)
            -&gt;withHeader('Content-Encoding', $encoding)
            -&gt;withHeader('Content-Length', strlen($compressed));
    }
    
    private function getBestEncoding(string $acceptEncoding): ?string {
        foreach ($this-&gt;supportedEncodings as $encoding) {
            if (strpos($acceptEncoding, $encoding) !== false) {
                return $encoding;
            }
        }
        return null;
    }
    
    private function compress(string $data, string $encoding): string {
        switch ($encoding) {
            case 'gzip':
                return gzencode($data, 6);
            case 'deflate':
                return gzcompress($data, 6);
            default:
                return $data;
        }
    }
}</code></pre>

                    <h2>Code-Level Optimizations</h2>

                    <h3>Efficient Array Operations</h3>

                    <pre><code class="language-php">class ArrayOptimizer {
    // Slow: Multiple array iterations
    public static function slowProcess(array $items): array {
        $filtered = array_filter($items, fn($item) =&gt; $item &gt; 10);
        $mapped = array_map(fn($item) =&gt; $item * 2, $filtered);
        return array_values($mapped);
    }
    
    // Fast: Single iteration
    public static function fastProcess(array $items): array {
        $result = [];
        foreach ($items as $item) {
            if ($item &gt; 10) {
                $result[] = $item * 2;
            }
        }
        return $result;
    }
    
    // Use array_column for efficient data extraction
    public static function extractColumn(array $data, string $column): array {
        return array_column($data, $column);
    }
    
    // Efficient array search
    public static function fastSearch(array $haystack, $needle): bool {
        // Use isset for array keys
        return isset($haystack[$needle]);
        
        // Use array_flip for value searches
        $flipped = array_flip($haystack);
        return isset($flipped[$needle]);
    }
}</code></pre>

                    <h3>String Optimization</h3>

                    <pre><code class="language-php">class StringOptimizer {
    // Use string concatenation efficiently
    public static function buildString(array $parts): string {
        // Slow: Multiple concatenations
        $result = '';
        foreach ($parts as $part) {
            $result .= $part;
        }
        return $result;
    }
    
    public static function buildStringFast(array $parts): string {
        // Fast: Single join operation
        return implode('', $parts);
    }
    
    // Use substr for string operations
    public static function extractSubstring(string $str, int $start, int $length): string {
        return substr($str, $start, $length);
    }
    
    // Use strpos for string searches
    public static function containsString(string $haystack, string $needle): bool {
        return strpos($haystack, $needle) !== false;
    }
}</code></pre>

                    <h2>Load Testing and Benchmarking</h2>

                    <h3>Simple Benchmarking</h3>

                    <pre><code class="language-php">class Benchmark {
    public static function run(callable $callback, int $iterations = 1000): array {
        $times = [];
        
        for ($i = 0; $i &lt; $iterations; $i++) {
            $start = microtime(true);
            $callback();
            $times[] = microtime(true) - $start;
        }
        
        return [
            'min' =&gt; min($times),
            'max' =&gt; max($times),
            'avg' =&gt; array_sum($times) / count($times),
            'median' =&gt; self::median($times),
            'total' =&gt; array_sum($times)
        ];
    }
    
    private static function median(array $values): float {
        sort($values);
        $count = count($values);
        $middle = floor($count / 2);
        
        if ($count % 2 === 0) {
            return ($values[$middle - 1] + $values[$middle]) / 2;
        }
        
        return $values[$middle];
    }
}</code></pre>

                    <h2>Production Monitoring</h2>

                    <h3>Real-time Performance Dashboard</h3>

                    <pre><code class="language-php">class PerformanceDashboard {
    private $redis;
    
    public function __construct(Redis $redis) {
        $this-&gt;redis = $redis;
    }
    
    public function recordMetric(string $name, float $value): void {
        $timestamp = time();
        $key = "metrics:{$name}";
        
        // Store in time series
        $this-&gt;redis-&gt;zadd($key, $timestamp, $value);
        
        // Keep only last hour of data
        $this-&gt;redis-&gt;zremrangebyscore($key, 0, $timestamp - 3600);
    }
    
    public function getMetrics(string $name, int $duration = 3600): array {
        $key = "metrics:{$name}";
        $from = time() - $duration;
        
        return $this-&gt;redis-&gt;zrangebyscore($key, $from, '+inf', [
            'withscores' =&gt; true
        ]);
    }
    
    public function getAverageResponseTime(): float {
        $metrics = $this-&gt;getMetrics('response_time');
        if (empty($metrics)) {
            return 0;
        }
        
        return array_sum($metrics) / count($metrics);
    }
}</code></pre>

                    <h2>Best Practices Summary</h2>

                    <ul>
                        <li><strong>Measure first:</strong> Use profiling tools to identify bottlenecks</li>
                        <li><strong>Optimize OPcache:</strong> Enable and configure properly</li>
                        <li><strong>Cache everything:</strong> Use multi-level caching strategies</li>
                        <li><strong>Database optimization:</strong> Connection pooling, query optimization</li>
                        <li><strong>Async processing:</strong> Move heavy operations to background jobs</li>
                        <li><strong>Memory management:</strong> Monitor memory usage and prevent leaks</li>
                        <li><strong>HTTP optimization:</strong> Compression, streaming, efficient headers</li>
                        <li><strong>Code optimization:</strong> Efficient algorithms and data structures</li>
                    </ul>

                    <h2>Common Pitfalls</h2>

                    <ul>
                        <li><strong>Premature optimization:</strong> Profile before optimizing</li>
                        <li><strong>Over-caching:</strong> Cache invalidation complexity</li>
                        <li><strong>Ignoring memory limits:</strong> Monitor memory usage</li>
                        <li><strong>Database over-optimization:</strong> Sometimes simple queries are better</li>
                        <li><strong>Micro-optimizations:</strong> Focus on significant bottlenecks</li>
                    </ul>

                    <p>High-performance PHP is achievable with the right techniques and tools. Start with measuring your current performance, identify the biggest bottlenecks, and apply optimizations systematically. Remember: the best optimization is the one that makes a measurable difference in your specific use case.</p>
                </div>

                <footer class="article-footer">
                    <div class="article-nav">
                        <a href="/articles.html" class="back-link">← Back to Articles</a>
                    </div>
                </footer>
            </div>
        </article>
    </main>

    <footer class="site-footer">
        <div class="container">
            <div class="footer-content">
                <p>© 2025 Joseph. All rights reserved.</p>
                <nav class="footer-nav">
                </nav>
            </div>
        </div>
    </footer>

    <script src="../js/main.js"></script>
    <script src="../js/syntax-highlighter.js"></script>

</body></html>