<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Proven techniques for optimizing PHP applications to handle high-turnover, high-complexity scenarios">
    <title>High-Performance PHP: Optimization Strategies | Joseph</title>
    <link rel="stylesheet" href="../css/main.css">
    <link rel="stylesheet" href="../css/articles.css">
    <link rel="stylesheet" href="../css/syntax-highlighting.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
</head>
<body>
    <header class="site-header">
        <nav class="nav-container">
            <div class="nav-brand">
                <a href="/" class="brand-link">Joseph</a>
            </div>
            <ul class="nav-menu">
                <li><a href="/" class="nav-link">Home</a></li>
                <li><a href="/services.html" class="nav-link">Services</a></li>
                <li><a href="/articles.html" class="nav-link">Articles</a></li>
                <li><a href="/about.html" class="nav-link">About</a></li>
                <li><a href="/author.html" class="nav-link">Author</a></li>
                <li><a href="/contact.html" class="nav-link">Contact</a></li>
            </ul>
            <button class="nav-toggle" aria-label="Toggle navigation">
                <span class="hamburger"></span>
            </button>
        </nav>
    </header>

    <main class="main-content">
        <article class="article-content">
            <div class="container">
                <header class="article-header">
                    <div class="article-meta">
                        <span class="article-category php">PHP</span>
                        <time datetime="2024-12-28">December 28, 2024</time>
                    </div>
                    <h1>High-Performance PHP: Optimization Strategies</h1>
                    <p class="article-lead">Proven techniques for optimizing PHP applications to handle high-turnover, high-complexity scenarios.</p>
                </header>

                <div class="article-body">
                    <p>PHP has a reputation for being slow, but that's largely outdated. Modern PHP 8.2+ with proper optimization can handle thousands of requests per second. The key is knowing where to optimize and how to measure the impact of your changes.</p>

                    <p>Over the years, I've optimized PHP applications handling millions of requests daily. Here are the techniques that deliver real performance gains.</p>

                    <h2>Performance Measurement Foundation</h2>

                    <h3>Profiling Tools</h3>

                    <p>You can't optimize what you don't measure. Essential profiling tools:</p>

                    <pre><code># Install Xdebug for profiling
pecl install xdebug

# php.ini configuration
zend_extension=xdebug.so
xdebug.mode=profile
xdebug.start_with_request=trigger
xdebug.output_dir="/tmp/xdebug"
xdebug.profiler_output_name="cachegrind.out.%p"</code></pre>

                    <p>Use with tools like KCacheGrind or Webgrind to visualize performance bottlenecks.</p>

                    <h3>Application Performance Monitoring</h3>

                    <pre><code><?php

declare(strict_types=1);

namespace App\Monitoring;

use App\ValueObjects\{MetricName, Duration};
use App\Exceptions\TimerNotFoundException;
use Psr\Log\LoggerInterface;

final class PerformanceMonitor
{
    /** @var array<string, float> */
    private array $timers = [];
    
    public function __construct(
        private readonly LoggerInterface $logger,
        private readonly MetricsCollector $metricsCollector,
    ) {}
    
    public function start(MetricName $name): void
    {
        $this->timers[$name->value] = hrtime(true);
    }
    
    public function end(MetricName $name): Duration
    {
        $timerKey = $name->value;
        
        if (!isset($this->timers[$timerKey])) {
            throw new TimerNotFoundException("Timer '{$timerKey}' not found");
        }
        
        $elapsed = Duration::fromNanoseconds(
            hrtime(true) - $this->timers[$timerKey]
        );
        
        unset($this->timers[$timerKey]);
        
        $this->metricsCollector->timing($name, $elapsed);
        
        $this->logger->debug('Performance metric recorded', [
            'metric' => $name->value,
            'duration_ms' => $elapsed->toMilliseconds(),
        ]);
        
        return $elapsed;
    }
}</code></pre>

                    <h2>OPcache Optimization</h2>

                    <p>OPcache is the most important PHP optimization. It caches compiled bytecode, eliminating the need to parse and compile PHP files on every request.</p>

                    <h3>Production OPcache Configuration</h3>

                    <pre><code># php.ini
opcache.enable=1
opcache.enable_cli=1
opcache.memory_consumption=512
opcache.interned_strings_buffer=64
opcache.max_accelerated_files=32531
opcache.validate_timestamps=0
opcache.save_comments=0
opcache.fast_shutdown=1
opcache.enable_file_override=1
opcache.optimization_level=0xffffffff

# JIT compilation for PHP 8.0+
opcache.jit_buffer_size=256M
opcache.jit=1255</code></pre>

                    <h3>OPcache Monitoring</h3>

                    <pre><code><?php

declare(strict_types=1);

namespace App\Monitoring\OPcache;

use App\ValueObjects\{HitRate, MemoryUsage};
use App\Exceptions\OPcacheNotAvailableException;

final readonly class OPcacheMonitor
{
    public function __construct(
        private OPcacheStatusReader $statusReader,
        private OPcacheConfigReader $configReader,
    ) {}
    
    public function getStats(): OPcacheStats
    {
        if (!extension_loaded('opcache')) {
            throw new OPcacheNotAvailableException('OPcache extension not loaded');
        }
        
        $status = $this->statusReader->read();
        $config = $this->configReader->read();
        
        return new OPcacheStats(
            enabled: $status['opcache_enabled'],
            hitRate: HitRate::fromFloat($status['opcache_statistics']['opcache_hit_rate']),
            memoryUsage: MemoryUsage::fromArray($status['memory_usage']),
            cachedScripts: $status['opcache_statistics']['num_cached_scripts'],
            maxCachedKeys: $config['directives']['opcache.max_accelerated_files'],
            jitEnabled: $config['directives']['opcache.jit_buffer_size'] > 0,
            jitBufferSize: $config['directives']['opcache.jit_buffer_size'],
        );
    }
    
    public function reset(): void
    {
        if (!opcache_reset()) {
            throw new OPcacheResetFailedException('Failed to reset OPcache');
        }
    }
    
    public function invalidateFile(string $filePath): void
    {
        if (!opcache_invalidate($filePath, true)) {
            throw new OPcacheInvalidationFailedException(
                "Failed to invalidate file: {$filePath}"
            );
        }
    }
}</code></pre>

                    <h2>Database Optimization</h2>

                    <h3>Connection Pooling</h3>

                    <p>Database connections are expensive. Use persistent connections wisely:</p>

                    <pre><code><?php

declare(strict_types=1);

namespace App\Database\Connection;

use App\ValueObjects\{ConnectionString, ConnectionId};
use App\Exceptions\{ConnectionPoolExhaustedException, ConnectionCreationFailedException};
use WeakMap;

final class DatabaseConnectionPool
{
    /** @var WeakMap<ConnectionId, PDO> */
    private WeakMap $connections;
    
    /** @var array<string, ConnectionId> */
    private array $connectionIds = [];
    
    public function __construct(
        private readonly ConnectionString $dsn,
        private readonly DatabaseCredentials $credentials,
        private readonly int $maxConnections = 20,
        private readonly ConnectionOptions $options = new ConnectionOptions(),
    ) {
        $this->connections = new WeakMap();
    }
    
    public function getConnection(): PDO
    {
        $connectionId = $this->findAvailableConnection() 
            ?? $this->createNewConnection();
        
        return $this->connections[$connectionId];
    }
    
    private function findAvailableConnection(): ?ConnectionId
    {
        foreach ($this->connectionIds as $id) {
            if ($this->connections->offsetExists($id)) {
                return $id;
            }
        }
        
        return null;
    }
    
    private function createNewConnection(): ConnectionId
    {
        if (count($this->connectionIds) >= $this->maxConnections) {
            throw new ConnectionPoolExhaustedException(
                "Maximum connections ({$this->maxConnections}) reached"
            );
        }
        
        $connectionId = ConnectionId::generate();
        
        try {
            $pdo = new PDO(
                $this->dsn->value,
                $this->credentials->username,
                $this->credentials->password,
                $this->options->toPdoOptions(),
            );
            
            $this->connections[$connectionId] = $pdo;
            $this->connectionIds[] = $connectionId;
            
            return $connectionId;
        } catch (PDOException $e) {
            throw new ConnectionCreationFailedException(
                "Failed to create database connection: {$e->getMessage()}",
                previous: $e
            );
        }
    }
}</code></pre>

                    <h3>Query Optimization</h3>

                    <pre><code><?php

declare(strict_types=1);

namespace App\Database\Performance;

use App\ValueObjects\{QueryDuration, QueryMetrics};
use App\Exceptions\SlowQueryThresholdExceededException;
use Psr\Log\LoggerInterface;

final readonly class QueryOptimizer
{
    /** @var array<int, QueryMetrics> */
    private array $queryLog = [];
    
    public function __construct(
        private PDO $pdo,
        private LoggerInterface $logger,
        private float $slowQueryThreshold = 0.1,
        private int $maxSlowQueries = 10,
    ) {}
    
    public function executeQuery(string $sql, array $params = []): array
    {
        $startTime = hrtime(true);
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($params);
        $result = $stmt->fetchAll();
        
        $duration = QueryDuration::fromNanoseconds(hrtime(true) - $startTime);
        
        if ($duration->exceeds($this->slowQueryThreshold)) {
            $this->logSlowQuery($sql, $params, $duration);
        }
        
        return $result;
    }
    
    private function logSlowQuery(string $sql, array $params, QueryDuration $duration): void
    {
        $metrics = new QueryMetrics(
            sql: $sql,
            parameters: $params,
            duration: $duration,
            executedAt: new DateTimeImmutable()
        );
        
        $this->queryLog[] = $metrics;
        
        $this->logger->warning('Slow query detected', [
            'sql' => $sql,
            'duration_ms' => $duration->toMilliseconds(),
            'parameters' => $params,
        ]);
        
        if (count($this->queryLog) > $this->maxSlowQueries) {
            throw new SlowQueryThresholdExceededException(
                "Too many slow queries detected: {$this->maxSlowQueries}"
            );
        }
    }
    
    /** @return array<QueryMetrics> */
    public function getQueryLog(): array
    {
        return $this->queryLog;
    }
    
    public function getAverageQueryTime(): QueryDuration
    {
        if (empty($this->queryLog)) {
            return QueryDuration::fromMilliseconds(0);
        }
        
        $totalNanoseconds = array_sum(
            array_map(
                fn(QueryMetrics $metrics) => $metrics->duration->toNanoseconds(),
                $this->queryLog
            )
        );
        
        return QueryDuration::fromNanoseconds($totalNanoseconds / count($this->queryLog));
    }
}</code></pre>

                    <h2>Caching Strategies</h2>

                    <h3>Multi-Level Caching</h3>

                    <pre><code><?php

declare(strict_types=1);

namespace App\Cache;

use App\ValueObjects\{CacheKey, CacheTTL};
use App\Exceptions\CacheSerializationException;
use Redis;
use WeakMap;

final class MultiLevelCacheManager
{
    /** @var array<string, mixed> */
    private array $memoryCache = [];
    private readonly bool $apcuAvailable;
    
    public function __construct(
        private readonly Redis $redis,
        private readonly CacheTTL $defaultTtl = new CacheTTL(3600),
    ) {
        $this->apcuAvailable = extension_loaded('apcu');
    }
    
    public function get(CacheKey $key, ?callable $callback = null, ?CacheTTL $ttl = null): mixed
    {
        $keyString = $key->toString();
        $ttl ??= $this->defaultTtl;
        
        // Level 1: Memory cache (fastest)
        if (isset($this->memoryCache[$keyString])) {
            return $this->memoryCache[$keyString];
        }
        
        // Level 2: APCu (shared memory)
        if ($this->apcuAvailable && apcu_exists($keyString)) {
            $value = apcu_fetch($keyString);
            $this->memoryCache[$keyString] = $value;
            return $value;
        }
        
        // Level 3: Redis (distributed cache)
        $serializedValue = $this->redis->get($keyString);
        if ($serializedValue !== false) {
            try {
                $value = unserialize($serializedValue);
                $this->memoryCache[$keyString] = $value;
                
                if ($this->apcuAvailable) {
                    apcu_store($keyString, $value, $ttl->toSeconds());
                }
                
                return $value;
            } catch (Throwable $e) {
                throw new CacheSerializationException(
                    "Failed to unserialize cached value for key: {$keyString}",
                    previous: $e
                );
            }
        }
        
        // Generate value if callback provided
        if ($callback !== null) {
            $value = $callback();
            $this->set($key, $value, $ttl);
            return $value;
        }
        
        return null;
    }
    
    public function set(CacheKey $key, mixed $value, ?CacheTTL $ttl = null): void
    {
        $keyString = $key->toString();
        $ttl ??= $this->defaultTtl;
        
        // Store in all cache levels
        $this->memoryCache[$keyString] = $value;
        
        if ($this->apcuAvailable) {
            apcu_store($keyString, $value, $ttl->toSeconds());
        }
        
        try {
            $this->redis->setex($keyString, $ttl->toSeconds(), serialize($value));
        } catch (Throwable $e) {
            throw new CacheSerializationException(
                "Failed to serialize value for key: {$keyString}",
                previous: $e
            );
        }
    }
    
    public function delete(CacheKey $key): void
    {
        $keyString = $key->toString();
        
        unset($this->memoryCache[$keyString]);
        
        if ($this->apcuAvailable) {
            apcu_delete($keyString);
        }
        
        $this->redis->del($keyString);
    }
    
    public function clear(): void
    {
        $this->memoryCache = [];
        
        if ($this->apcuAvailable) {
            apcu_clear_cache();
        }
        
        $this->redis->flushdb();
    }
}</code></pre>

                    <h3>Smart Cache Invalidation</h3>

                    <pre><code><?php

declare(strict_types=1);

namespace App\Cache;

use App\ValueObjects\{CacheKey, CacheTag, CacheTTL};
use App\Exceptions\CacheInvalidationException;
use App\Contracts\CacheInterface;
use Psr\Log\LoggerInterface;

final readonly class TaggedCacheInvalidator
{
    public function __construct(
        private CacheInterface $cache,
        private LoggerInterface $logger,
    ) {}
    
    /** @param array<CacheTag> $tags */
    public function setWithTags(
        CacheKey $key,
        mixed $value,
        array $tags,
        ?CacheTTL $ttl = null
    ): void {
        $this->cache->set($key, $value, $ttl);
        
        // Associate key with tags
        foreach ($tags as $tag) {
            $tagKey = CacheKey::forTag($tag);
            $existingKeys = $this->cache->get($tagKey, fn() => []);
            $existingKeys[] = $key->toString();
            
            $this->cache->set(
                $tagKey,
                array_unique($existingKeys),
                $ttl
            );
        }
        
        $this->logger->debug('Cache entry created with tags', [
            'key' => $key->toString(),
            'tags' => array_map(fn(CacheTag $tag) => $tag->toString(), $tags),
        ]);
    }
    
    public function invalidateTag(CacheTag $tag): void
    {
        $tagKey = CacheKey::forTag($tag);
        $keys = $this->cache->get($tagKey, fn() => []);
        
        $invalidatedCount = 0;
        
        foreach ($keys as $keyString) {
            try {
                $this->cache->delete(CacheKey::fromString($keyString));
                $invalidatedCount++;
            } catch (Throwable $e) {
                $this->logger->error('Failed to invalidate cache key', [
                    'key' => $keyString,
                    'tag' => $tag->toString(),
                    'error' => $e->getMessage(),
                ]);
            }
        }
        
        $this->cache->delete($tagKey);
        
        $this->logger->info('Cache tag invalidated', [
            'tag' => $tag->toString(),
            'keys_invalidated' => $invalidatedCount,
        ]);
    }
    
    /** @param array<CacheTag> $tags */
    public function invalidateTags(array $tags): void
    {
        foreach ($tags as $tag) {
            $this->invalidateTag($tag);
        }
    }
    
    public function invalidatePattern(string $pattern): void
    {
        if (!$this->cache instanceof RedisCache) {
            throw new CacheInvalidationException(
                'Pattern invalidation only supported for Redis cache'
            );
        }
        
        $keys = $this->cache->getRedisInstance()->keys($pattern);
        
        if (empty($keys)) {
            return;
        }
        
        $this->cache->getRedisInstance()->del($keys);
        
        $this->logger->info('Cache pattern invalidated', [
            'pattern' => $pattern,
            'keys_invalidated' => count($keys),
        ]);
    }
}</code></pre>

                    <h2>Memory Management</h2>

                    <h3>Object Pooling</h3>

                    <pre><code><?php

declare(strict_types=1);

namespace App\ObjectPool;

use App\Contracts\{PoolableInterface, ObjectFactoryInterface};
use App\Exceptions\PoolExhaustedException;
use App\ValueObjects\PoolSize;
use SplQueue;

final class ObjectPool
{
    private readonly SplQueue $pool;
    private int $currentSize = 0;
    
    public function __construct(
        private readonly ObjectFactoryInterface $factory,
        private readonly PoolSize $maxSize = new PoolSize(100),
    ) {
        $this->pool = new SplQueue();
    }
    
    public function get(): PoolableInterface
    {
        if ($this->pool->isEmpty()) {
            return $this->factory->create();
        }
        
        return $this->pool->dequeue();
    }
    
    public function return(PoolableInterface $object): void
    {
        if ($this->pool->count() >= $this->maxSize->value) {
            // Pool is full, let object be garbage collected
            return;
        }
        
        // Reset object state before returning to pool
        $object->reset();
        
        $this->pool->enqueue($object);
    }
    
    public function size(): int
    {
        return $this->pool->count();
    }
    
    public function drain(): void
    {
        while (!$this->pool->isEmpty()) {
            $this->pool->dequeue();
        }
    }
}

// Usage example with factory
final readonly class HttpClientFactory implements ObjectFactoryInterface
{
    public function create(): PoolableInterface
    {
        return new PoolableHttpClient(
            new GuzzleHttp\Client([
                'timeout' => 30,
                'connect_timeout' => 5,
            ])
        );
    }
}

$httpClientPool = new ObjectPool(
    new HttpClientFactory(),
    new PoolSize(50)
);

function makeHttpRequest(string $url): string
{
    $client = $httpClientPool->get();
    try {
        $response = $client->get($url);
        return $response->getBody();
    } finally {
        $httpClientPool->return($client);
    }
}</code></pre>

                    <h3>Memory Leak Detection</h3>

                    <pre><code><?php

declare(strict_types=1);

namespace App\Profiling;

use App\ValueObjects\{MemoryUsage, Duration, CheckpointName};
use App\Exceptions\CheckpointNotFoundException;
use DateTimeImmutable;

final class MemoryProfiler
{
    /** @var array<string, MemoryCheckpoint> */
    private array $checkpoints = [];
    
    public function checkpoint(CheckpointName $name): void
    {
        $this->checkpoints[$name->value] = new MemoryCheckpoint(
            name: $name,
            memoryUsage: MemoryUsage::current(),
            peakMemoryUsage: MemoryUsage::peak(),
            timestamp: new DateTimeImmutable()
        );
    }
    
    public function getDiff(CheckpointName $from, CheckpointName $to): MemoryDiff
    {
        $fromCheckpoint = $this->checkpoints[$from->value] ?? null;
        $toCheckpoint = $this->checkpoints[$to->value] ?? null;
        
        if ($fromCheckpoint === null || $toCheckpoint === null) {
            throw new CheckpointNotFoundException(
                "Checkpoint not found: {$from->value} or {$to->value}"
            );
        }
        
        return new MemoryDiff(
            from: $fromCheckpoint,
            to: $toCheckpoint,
            memoryDiff: $toCheckpoint->memoryUsage->subtract($fromCheckpoint->memoryUsage),
            peakDiff: $toCheckpoint->peakMemoryUsage->subtract($fromCheckpoint->peakMemoryUsage),
            timeDiff: Duration::between($fromCheckpoint->timestamp, $toCheckpoint->timestamp)
        );
    }
    
    /** @return array<string, MemoryDiff> */
    public function getReport(): array
    {
        $report = [];
        $checkpointNames = array_keys($this->checkpoints);
        
        for ($i = 1; $i < count($checkpointNames); $i++) {
            $from = CheckpointName::fromString($checkpointNames[$i - 1]);
            $to = CheckpointName::fromString($checkpointNames[$i]);
            $report["{$from->value} → {$to->value}"] = $this->getDiff($from, $to);
        }
        
        return $report;
    }
    
    public function reset(): void
    {
        $this->checkpoints = [];
    }
    
    public function hasCheckpoint(CheckpointName $name): bool
    {
        return isset($this->checkpoints[$name->value]);
    }
    
    public function getCheckpoint(CheckpointName $name): ?MemoryCheckpoint
    {
        return $this->checkpoints[$name->value] ?? null;
    }
}</code></pre>

                    <h2>Asynchronous Processing</h2>

                    <h3>Job Queue Implementation</h3>

                    <pre><code><?php

declare(strict_types=1);

namespace App\Queue;

use App\ValueObjects\{QueueName, JobDelay, JobId};
use App\Exceptions\{JobSerializationException, QueueOperationException};
use App\Contracts\{JobInterface, QueueInterface};
use Redis;
use Psr\Log\LoggerInterface;

final readonly class RedisJobQueue implements QueueInterface
{
    public function __construct(
        private Redis $redis,
        private QueueName $queueName,
        private LoggerInterface $logger,
    ) {}
    
    public function push(JobInterface $job, ?JobDelay $delay = null): void
    {
        try {
            $payload = serialize($job);
        } catch (Throwable $e) {
            throw new JobSerializationException(
                "Failed to serialize job: {$job::class}",
                previous: $e
            );
        }
        
        if ($delay !== null && $delay->getSeconds() > 0) {
            $this->redis->zadd(
                "queue:{$this->queueName->value}:delayed",
                time() + $delay->getSeconds(),
                $payload
            );
        } else {
            $this->redis->lpush("queue:{$this->queueName->value}", $payload);
        }
        
        $this->logger->debug('Job pushed to queue', [
            'queue' => $this->queueName->value,
            'job_type' => $job::class,
            'delayed' => $delay?->getSeconds() ?? 0,
        ]);
    }
    
    public function pop(int $timeout = 0): ?JobInterface
    {
        $this->moveDelayedJobs();
        
        $result = $this->redis->brpop("queue:{$this->queueName->value}", $timeout);
        
        if (!$result) {
            return null;
        }
        
        try {
            return unserialize($result[1]);
        } catch (Throwable $e) {
            throw new JobSerializationException(
                "Failed to unserialize job from queue: {$this->queueName->value}",
                previous: $e
            );
        }
    }
    
    private function moveDelayedJobs(): void
    {
        $now = time();
        $jobs = $this->redis->zrangebyscore(
            "queue:{$this->queueName->value}:delayed",
            0,
            $now
        );
        
        foreach ($jobs as $job) {
            $this->redis->lpush("queue:{$this->queueName->value}", $job);
            $this->redis->zrem("queue:{$this->queueName->value}:delayed", $job);
        }
    }
    
    public function size(): int
    {
        return $this->redis->llen("queue:{$this->queueName->value}");
    }
    
    public function clear(): void
    {
        $this->redis->del("queue:{$this->queueName->value}");
        $this->redis->del("queue:{$this->queueName->value}:delayed");
    }
}

abstract readonly class Job implements JobInterface
{
    protected int $attempts = 0;
    protected int $maxAttempts = 3;
    
    public function __construct(
        protected readonly JobId $id,
        protected readonly array $data = [],
    ) {}
    
    abstract public function handle(): void;
    
    public function failed(Throwable $exception): void
    {
        // Override in subclasses for custom failure handling
    }
    
    public function shouldRetry(): bool
    {
        return $this->attempts < $this->maxAttempts;
    }
    
    public function incrementAttempts(): void
    {
        $this->attempts++;
    }
    
    public function getAttempts(): int
    {
        return $this->attempts;
    }
    
    public function getMaxAttempts(): int
    {
        return $this->maxAttempts;
    }
    
    public function getId(): JobId
    {
        return $this->id;
    }
}</code></pre>

                    <h2>HTTP Performance Optimization</h2>

                    <h3>Response Streaming</h3>

                    <pre><code>class StreamingResponse {
    private $callback;
    private $headers = [];
    
    public function __construct(callable $callback) {
        $this->callback = $callback;
    }
    
    public function setHeader(string $name, string $value): void {
        $this->headers[$name] = $value;
    }
    
    public function send(): void {
        // Send headers
        foreach ($this->headers as $name => $value) {
            header("{$name}: {$value}");
        }
        
        // Disable output buffering
        if (ob_get_level()) {
            ob_end_clean();
        }
        
        // Send content in chunks
        ($this->callback)();
    }
}

// Usage for large data sets
function streamLargeDataset(): void {
    $response = new StreamingResponse(function() {
        echo "[\n";
        
        $first = true;
        foreach (getLargeDataset() as $item) {
            if (!$first) {
                echo ",\n";
            }
            echo json_encode($item);
            $first = false;
            
            // Flush output buffer
            flush();
        }
        
        echo "\n]";
    });
    
    $response->setHeader('Content-Type', 'application/json');
    $response->send();
}</code></pre>

                    <h3>Response Compression</h3>

                    <pre><code>class CompressionMiddleware {
    private $minSize = 1024;
    private $supportedEncodings = ['gzip', 'deflate'];
    
    public function handle(Request $request, callable $next): Response {
        $response = $next($request);
        
        // Check if compression is supported
        $acceptEncoding = $request->getHeader('Accept-Encoding');
        $encoding = $this->getBestEncoding($acceptEncoding);
        
        if (!$encoding || strlen($response->getBody()) < $this->minSize) {
            return $response;
        }
        
        // Compress response
        $compressed = $this->compress($response->getBody(), $encoding);
        
        return $response
            ->withBody($compressed)
            ->withHeader('Content-Encoding', $encoding)
            ->withHeader('Content-Length', strlen($compressed));
    }
    
    private function getBestEncoding(string $acceptEncoding): ?string {
        foreach ($this->supportedEncodings as $encoding) {
            if (strpos($acceptEncoding, $encoding) !== false) {
                return $encoding;
            }
        }
        return null;
    }
    
    private function compress(string $data, string $encoding): string {
        switch ($encoding) {
            case 'gzip':
                return gzencode($data, 6);
            case 'deflate':
                return gzcompress($data, 6);
            default:
                return $data;
        }
    }
}</code></pre>

                    <h2>Code-Level Optimizations</h2>

                    <h3>Efficient Array Operations</h3>

                    <pre><code>class ArrayOptimizer {
    // Slow: Multiple array iterations
    public static function slowProcess(array $items): array {
        $filtered = array_filter($items, fn($item) => $item > 10);
        $mapped = array_map(fn($item) => $item * 2, $filtered);
        return array_values($mapped);
    }
    
    // Fast: Single iteration
    public static function fastProcess(array $items): array {
        $result = [];
        foreach ($items as $item) {
            if ($item > 10) {
                $result[] = $item * 2;
            }
        }
        return $result;
    }
    
    // Use array_column for efficient data extraction
    public static function extractColumn(array $data, string $column): array {
        return array_column($data, $column);
    }
    
    // Efficient array search
    public static function fastSearch(array $haystack, $needle): bool {
        // Use isset for array keys
        return isset($haystack[$needle]);
        
        // Use array_flip for value searches
        $flipped = array_flip($haystack);
        return isset($flipped[$needle]);
    }
}</code></pre>

                    <h3>String Optimization</h3>

                    <pre><code>class StringOptimizer {
    // Use string concatenation efficiently
    public static function buildString(array $parts): string {
        // Slow: Multiple concatenations
        $result = '';
        foreach ($parts as $part) {
            $result .= $part;
        }
        return $result;
    }
    
    public static function buildStringFast(array $parts): string {
        // Fast: Single join operation
        return implode('', $parts);
    }
    
    // Use substr for string operations
    public static function extractSubstring(string $str, int $start, int $length): string {
        return substr($str, $start, $length);
    }
    
    // Use strpos for string searches
    public static function containsString(string $haystack, string $needle): bool {
        return strpos($haystack, $needle) !== false;
    }
}</code></pre>

                    <h2>Load Testing and Benchmarking</h2>

                    <h3>Simple Benchmarking</h3>

                    <pre><code>class Benchmark {
    public static function run(callable $callback, int $iterations = 1000): array {
        $times = [];
        
        for ($i = 0; $i < $iterations; $i++) {
            $start = microtime(true);
            $callback();
            $times[] = microtime(true) - $start;
        }
        
        return [
            'min' => min($times),
            'max' => max($times),
            'avg' => array_sum($times) / count($times),
            'median' => self::median($times),
            'total' => array_sum($times)
        ];
    }
    
    private static function median(array $values): float {
        sort($values);
        $count = count($values);
        $middle = floor($count / 2);
        
        if ($count % 2 === 0) {
            return ($values[$middle - 1] + $values[$middle]) / 2;
        }
        
        return $values[$middle];
    }
}</code></pre>

                    <h2>Production Monitoring</h2>

                    <h3>Real-time Performance Dashboard</h3>

                    <pre><code>class PerformanceDashboard {
    private $redis;
    
    public function __construct(Redis $redis) {
        $this->redis = $redis;
    }
    
    public function recordMetric(string $name, float $value): void {
        $timestamp = time();
        $key = "metrics:{$name}";
        
        // Store in time series
        $this->redis->zadd($key, $timestamp, $value);
        
        // Keep only last hour of data
        $this->redis->zremrangebyscore($key, 0, $timestamp - 3600);
    }
    
    public function getMetrics(string $name, int $duration = 3600): array {
        $key = "metrics:{$name}";
        $from = time() - $duration;
        
        return $this->redis->zrangebyscore($key, $from, '+inf', [
            'withscores' => true
        ]);
    }
    
    public function getAverageResponseTime(): float {
        $metrics = $this->getMetrics('response_time');
        if (empty($metrics)) {
            return 0;
        }
        
        return array_sum($metrics) / count($metrics);
    }
}</code></pre>

                    <h2>Best Practices Summary</h2>

                    <ul>
                        <li><strong>Measure first:</strong> Use profiling tools to identify bottlenecks</li>
                        <li><strong>Optimize OPcache:</strong> Enable and configure properly</li>
                        <li><strong>Cache everything:</strong> Use multi-level caching strategies</li>
                        <li><strong>Database optimization:</strong> Connection pooling, query optimization</li>
                        <li><strong>Async processing:</strong> Move heavy operations to background jobs</li>
                        <li><strong>Memory management:</strong> Monitor memory usage and prevent leaks</li>
                        <li><strong>HTTP optimization:</strong> Compression, streaming, efficient headers</li>
                        <li><strong>Code optimization:</strong> Efficient algorithms and data structures</li>
                    </ul>

                    <h2>Common Pitfalls</h2>

                    <ul>
                        <li><strong>Premature optimization:</strong> Profile before optimizing</li>
                        <li><strong>Over-caching:</strong> Cache invalidation complexity</li>
                        <li><strong>Ignoring memory limits:</strong> Monitor memory usage</li>
                        <li><strong>Database over-optimization:</strong> Sometimes simple queries are better</li>
                        <li><strong>Micro-optimizations:</strong> Focus on significant bottlenecks</li>
                    </ul>

                    <p>High-performance PHP is achievable with the right techniques and tools. Start with measuring your current performance, identify the biggest bottlenecks, and apply optimizations systematically. Remember: the best optimization is the one that makes a measurable difference in your specific use case.</p>
                </div>

                <footer class="article-footer">
                    <div class="article-nav">
                        <a href="/articles.html" class="back-link">← Back to Articles</a>
                    </div>
                </footer>
            </div>
        </article>
    </main>

    <footer class="site-footer">
        <div class="container">
            <div class="footer-content">
                <p>&copy; 2025 Joseph. All rights reserved.</p>
                <nav class="footer-nav">
                </nav>
            </div>
        </div>
    </footer>

    <script src="../js/main.js"></script>
    <script src="../js/syntax-highlighter.js"></script>
</body>
</html>